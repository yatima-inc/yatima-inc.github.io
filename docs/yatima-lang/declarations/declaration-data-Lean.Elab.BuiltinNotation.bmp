{"name":"Lean.Elab.BuiltinNotation","instances":[],"imports":["Init","Init.Data.ToString","Lean.Compiler.BorrowedAnnotation","Lean.Meta.KAbstract","Lean.Meta.Transform","Lean.Elab.App","Lean.Elab.SyntheticMVars"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L385-L387","name":"Lean.Elab.Term.elabNoindex","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabNoindex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L374-L383","name":"Lean.Elab.Term.elabStateRefT","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabStateRefT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L307-L372","name":"Lean.Elab.Term.elabSubst","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabSubst","doc":"`h ▸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h ▸ e` has type `p b`.\nYou can also view `h ▸ e` as a \"type casting\" operation where you change the type of `e` by using `h`.\nSee the Chapter \"Quantifiers and Equality\" in the manual \"Theorem Proving in Lean\" for additional information.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L274-L280","name":"Lean.Elab.Term.elabParen","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabParen","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L257-L272","name":"Lean.Elab.Term.expandParen","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.expandParen","doc":"You can use parentheses for\n- Grouping expressions, e.g., `a * (b + c)`.\n- Creating tuples, e.g., `(a, b, c)` is notation for `Prod.mk a (Prod.mk b c)`.\n- Performing type ascription, e.g., `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\n- Creating `Unit.unit`, `()` is just a shorthand for `Unit.unit`.\n- Creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L239-L242","name":"Lean.Elab.Term.elabCDotFunctionAlias?.expandCDotArg?","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabCDotFunctionAlias?.expandCDotArg?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L223-L242","name":"Lean.Elab.Term.elabCDotFunctionAlias?","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabCDotFunctionAlias?","doc":"Helper method for elaborating terms such as `(.+.)` where a constant name is expected.\nThis method is usually used to implement tactics that function names as arguments (e.g., `simp`).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L207-L217","name":"Lean.Elab.Term.expandCDot?.go","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.expandCDot?.go","doc":"Auxiliary function for expanding the `·` notation.\nThe extra state `Array Syntax` contains the new binder names.\nIf `stx` is a `·`, we create a fresh identifier, store in the\nextra state, and return it. Otherwise, we just return `stx`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L195-L217","name":"Lean.Elab.Term.expandCDot?","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.expandCDot?","doc":"Return `some` if succeeded expanding `·` notation occurring in\nthe given syntax. Otherwise, return `none`.\nExamples:\n- `· + 1` => `fun _a_1 => _a_1 + 1`\n- `f · · b` => `fun _a_1 _a_2 => f _a_1 _a_2 b` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L172-L179","name":"Lean.Elab.Term.mkPairs.loop","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.mkPairs.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L171-L180","name":"Lean.Elab.Term.mkPairs","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.mkPairs","doc":"Return syntax `Prod.mk elems[0] (Prod.mk elems[1] ... (Prod.mk elems[elems.size - 2] elems[elems.size - 1])))` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L166-L168","name":"Lean.Elab.Term.elabSorry","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabSorry","doc":"A temporary placeholder for a missing proof or value. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L160-L163","name":"Lean.Elab.Term.expandDbgTrace","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.expandDbgTrace","doc":"`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L149-L155","name":"Lean.Elab.Term.expandAssert","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.expandAssert","doc":"`assert! cond` panics if `cond` evaluates to `false`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L145-L146","name":"Lean.Elab.Term.expandUnreachable","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.expandUnreachable","doc":"A shorthand for `panic! \"unreachable code has been reached\"`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L133-L142","name":"Lean.Elab.Term.elabPanic","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabPanic","doc":"`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L120-L124","name":"Lean.Elab.Term.elabTrailingParserMacro","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabTrailingParserMacro","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L108-L112","name":"Lean.Elab.Term.elabLeadingParserMacro","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabLeadingParserMacro","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L92-L95","name":"Lean.Elab.Term.expandSuffices","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.expandSuffices","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L82-L90","name":"Lean.Elab.Term.expandHave","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.expandHave","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L76-L80","name":"Lean.Elab.Term.expandShow","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.expandShow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L71-L74","name":"Lean.Elab.Term.elabBorrowed","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabBorrowed","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L35-L69","name":"Lean.Elab.Term.elabAnonymousCtor","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabAnonymousCtor","doc":"The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/BuiltinNotation.lean#L16-L27","name":"Lean.Elab.Term.elabCoe","docLink":"./Lean/Elab/BuiltinNotation.html#Lean.Elab.Term.elabCoe","doc":""}]}