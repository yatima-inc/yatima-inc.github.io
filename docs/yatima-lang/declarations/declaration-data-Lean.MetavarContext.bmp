{"name":"Lean.MetavarContext","instances":[{"typeNames":["Lean.LocalInstance"],"name":"Lean.instInhabitedLocalInstance","className":"Inhabited"},{"typeNames":["Lean.LocalInstance"],"name":"Lean.instBEqLocalInstance","className":"BEq"},{"typeNames":["Lean.MetavarKind"],"name":"Lean.instInhabitedMetavarKind","className":"Inhabited"},{"typeNames":["Lean.MetavarKind"],"name":"Lean.instReprMetavarKind","className":"Repr"},{"typeNames":["Lean.MetavarDecl"],"name":"Lean.instInhabitedMetavarDecl","className":"Inhabited"},{"typeNames":[],"name":"Lean.instMonadMCtx","className":"Lean.MonadMCtx"},{"typeNames":["StateRefT'","Lean.MetavarContext","ST"],"name":"Lean.instMonadMCtxStateRefT'MetavarContextST","className":"Lean.MonadMCtx"},{"typeNames":["_private.Lean.MetavarContext.0.Lean.DependsOn.M"],"name":"Lean.DependsOn.instMonadMCtxM","className":"Lean.MonadMCtx"},{"typeNames":["Lean.MetavarContext"],"name":"Lean.MetavarContext.instInhabitedMetavarContext","className":"Inhabited"},{"typeNames":["StateRefT'","Lean.MetavarContext","ST"],"name":"Lean.MetavarContext.instMonadMCtxStateRefT'MetavarContextST","className":"Lean.MonadMCtx"},{"typeNames":["Lean.MetavarContext.MkBinding.Exception"],"name":"Lean.MetavarContext.MkBinding.instToStringException","className":"ToString"},{"typeNames":["Lean.MetavarContext.MkBinding.M"],"name":"Lean.MetavarContext.MkBinding.instMonadMCtxM","className":"Lean.MonadMCtx"},{"typeNames":["Lean.ExprStructEq","Lean.Expr","Lean.MetavarContext.MkBinding.M","Lean.ExprStructEq.instBEqExprStructEq","Lean.ExprStructEq.instHashableExprStructEq"],"name":"Lean.MetavarContext.MkBinding.instMonadHashMapCacheAdapterExprStructEqExprMInstBEqExprStructEqInstHashableExprStructEq","className":"Lean.MonadHashMapCacheAdapter"},{"typeNames":["Lean.MetavarContext.LevelMVarToParam.M"],"name":"Lean.MetavarContext.LevelMVarToParam.instMonadMCtxM","className":"Lean.MonadMCtx"},{"typeNames":["Lean.ExprStructEq","Lean.Expr","Lean.MetavarContext.LevelMVarToParam.M"],"name":"Lean.MetavarContext.LevelMVarToParam.instMonadCacheExprStructEqExprM","className":"Lean.MonadCache"}],"imports":["Init","Lean.Util.MonadCache","Lean.LocalContext"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1305-L1306","name":"Lean.MetavarContext.getExprAssignmentDomain","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.getExprAssignmentDomain","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1297-L1303","name":"Lean.MetavarContext.levelMVarToParam","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.levelMVarToParam","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1291-L1295","name":"Lean.MetavarContext.UnivMVarParamResult","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.UnivMVarParamResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1281-L1287","name":"Lean.MetavarContext.LevelMVarToParam.main.visitApp","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.LevelMVarToParam.main.visitApp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1264-L1287","name":"Lean.MetavarContext.LevelMVarToParam.main","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.LevelMVarToParam.main","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1245-L1262","name":"Lean.MetavarContext.LevelMVarToParam.visitLevel","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.LevelMVarToParam.visitLevel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1234-L1243","name":"Lean.MetavarContext.LevelMVarToParam.mkParamName","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.LevelMVarToParam.mkParamName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1230-L1232","name":"Lean.MetavarContext.LevelMVarToParam.instMonadCacheExprStructEqExprM","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.LevelMVarToParam.instMonadCacheExprStructEqExprM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1226-L1228","name":"Lean.MetavarContext.LevelMVarToParam.instMonadMCtxM","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.LevelMVarToParam.instMonadMCtxM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1224-L1224","name":"Lean.MetavarContext.LevelMVarToParam.M","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.LevelMVarToParam.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1218-L1222","name":"Lean.MetavarContext.LevelMVarToParam.State","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.LevelMVarToParam.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1213-L1216","name":"Lean.MetavarContext.LevelMVarToParam.Context","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.LevelMVarToParam.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1191-L1209","name":"Lean.MetavarContext.isWellFormed","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.isWellFormed","doc":"`isWellFormed mctx lctx e` return true if\n- All locals in `e` are declared in `lctx`\n- All metavariables `?m` in `e` have a local context which is a subprefix of `lctx` or are assigned, and the assignment is well-formed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1184-L1185","name":"Lean.MetavarContext.collectForwardDeps","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.collectForwardDeps","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1181-L1182","name":"Lean.MetavarContext.abstractRange","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.abstractRange","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1178-L1179","name":"Lean.MetavarContext.mkForall","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.mkForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1175-L1176","name":"Lean.MetavarContext.mkLambda","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.mkLambda","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1171-L1173","name":"Lean.MetavarContext.mkBinding","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.mkBinding","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1168-L1169","name":"Lean.MetavarContext.revert","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.revert","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1165-L1166","name":"Lean.MetavarContext.elimMVarDeps","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.elimMVarDeps","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1163-L1163","name":"Lean.MetavarContext.MkBindingM","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBindingM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1159-L1161","name":"Lean.MetavarContext.MkBindingM.Context","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBindingM.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1124-L1155","name":"Lean.MetavarContext.MkBinding.mkBinding","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.mkBinding","doc":"Similar to `LocalContext.mkBinding`, but handles metavariables correctly.\nIf `usedOnly == false` then `forall` and `lambda` expressions are created only for used variables.\nIf `usedLetOnly == false` then `let` expressions are created only for used (let-) variables. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1116-L1118","name":"Lean.MetavarContext.MkBinding.abstractRange","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.abstractRange","doc":"Similar to `Expr.abstractRange`, but handles metavariables correctly.\n  It uses `elimMVarDeps` to ensure `e` and the type of the free variables `xs` do not\n  contain a metavariable `?m` s.t. local context of `?m` contains a free variable in `xs`.\n\n  `elimMVarDeps` is defined later in this file. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1106-L1108","name":"Lean.MetavarContext.MkBinding.revert","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.revert","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L1099-L1104","name":"Lean.MetavarContext.MkBinding.elimMVarDeps","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.elimMVarDeps","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L945-L947","name":"Lean.MetavarContext.MkBinding.reduceLocalContext","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.reduceLocalContext","doc":"Create a new `LocalContext` by removing the free variables in `toRevert` from `lctx`.\nWe use this function when we create auxiliary metavariables at `elimMVarDepsAux`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L917-L941","name":"Lean.MetavarContext.MkBinding.collectForwardDeps","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.collectForwardDeps","doc":"Given `toRevert` an array of free variables s.t. `lctx` contains their declarations,\n  return a new array of free variables that contains `toRevert` and all free variables\n  in `lctx` that may depend on `toRevert`.\n\n  Remark: the result is sorted by `LocalDecl` indices.\n\n  Remark: We used to throw an `Exception.revertFailure` exception when an auxiliary declaration\n  had to be reversed. Recall that auxiliary declarations are created when compiling (mutually)\n  recursive definitions. The `revertFailure` due to auxiliary declaration dependency was originally\n  introduced in Lean3 to address issue https://github.com/leanprover/lean/issues/1258.\n  In Lean4, this solution is not satisfactory because all definitions/theorems are potentially\n  recursive. So, even an simple (incomplete) definition such as\n  ```\n  variables {α : Type} in\n  def f (a : α) : List α :=\n  _\n  ```\n  would trigger the `Exception.revertFailure` exception. In the definition above,\n  the elaborator creates the auxiliary definition `f : {α : Type} → List α`.\n  The `_` is elaborated as a new fresh variable `?m` that contains `α : Type`, `a : α`, and `f : α → List α` in its context,\n  When we try to create the lambda `fun {α : Type} (a : α) => ?m`, we first need to create\n  an auxiliary `?n` which do not contain `α` and `a` in its context. That is,\n  we create the metavariable `?n : {α : Type} → (a : α) → (f : α → List α) → List α`,\n  add the delayed assignment `?n #[α, a, f] := ?m α a f`, and create the lambda\n  `fun {α : Type} (a : α) => ?n α a f`.\n  See `elimMVarDeps` for more information.\n  If we kept using the Lean3 approach, we would get the `Exception.revertFailure` exception because we are\n  reverting the auxiliary definition `f`.\n\n  Note that https://github.com/leanprover/lean/issues/1258 is not an issue in Lean4 because\n  we have changed how we compile recursive definitions.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L870-L872","name":"Lean.MetavarContext.MkBinding.instMonadHashMapCacheAdapterExprStructEqExprMInstBEqExprStructEqInstHashableExprStructEq","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.instMonadHashMapCacheAdapterExprStructEqExprMInstBEqExprStructEqInstHashableExprStructEq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L867-L868","name":"Lean.MetavarContext.MkBinding.preserveOrder","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.preserveOrder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L859-L861","name":"Lean.MetavarContext.MkBinding.instMonadMCtxM","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.instMonadMCtxM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L857-L857","name":"Lean.MetavarContext.MkBinding.M","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L856-L856","name":"Lean.MetavarContext.MkBinding.MCore","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.MCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L848-L854","name":"Lean.MetavarContext.MkBinding.Context","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L842-L846","name":"Lean.MetavarContext.MkBinding.State","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.State","doc":"`MkBinding` and `elimMVarDepsAux` are mutually recursive, but `cache` is only used at `elimMVarDepsAux`.\n  We use a single state object for convenience.\n\n  We have a `NameGenerator` because we need to generate fresh auxiliary metavariables. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L829-L835","name":"Lean.MetavarContext.MkBinding.instToStringException","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.instToStringException","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L826-L827","name":"Lean.MetavarContext.MkBinding.Exception","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.MkBinding.Exception","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L820-L822","name":"Lean.MetavarContext.instMonadMCtxStateRefT'MetavarContextST","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.instMonadMCtxStateRefT'MetavarContextST","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L817-L818","name":"Lean.MetavarContext.incDepth","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.incDepth","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L812-L815","name":"Lean.MetavarContext.isAnonymousMVar","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.isAnonymousMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L807-L810","name":"Lean.MetavarContext.getLevelDepth","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.getLevelDepth","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L804-L805","name":"Lean.MetavarContext.findLevelDepth?","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.findLevelDepth?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L800-L802","name":"Lean.MetavarContext.setMVarType","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.setMVarType","doc":"Update the type of the given metavariable. This function assumes the new type is\ndefinitionally equal to the current one "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L794-L796","name":"Lean.MetavarContext.setMVarUserNameTemporarily","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.setMVarUserNameTemporarily","doc":"Low-level version of `setMVarUserName`.\nIt does not update the table `userNames`. Thus, `findUserName?` cannot see the modification.\nIt is meant for `mkForallFVars'` where we temporarily set the user facing name of metavariables to get more\nmeaningful binder names.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L780-L786","name":"Lean.MetavarContext.setMVarUserName","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.setMVarUserName","doc":"Set the metavariable user facing name.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L773-L775","name":"Lean.MetavarContext.setMVarKind","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.setMVarKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L770-L771","name":"Lean.MetavarContext.findUserName?","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.findUserName?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L767-L768","name":"Lean.MetavarContext.findDecl?","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.findDecl?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L764-L765","name":"Lean.MetavarContext.addLevelMVarDecl","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.addLevelMVarDecl","doc":"Low level API for adding/declaring universe level metavariable declarations.\nIt is used to implement actions in the monads `MetaM`, `ElabM` and `TacticM`.\nIt should not be used directly since the argument `(mvarId : MVarId)` is assumed to be \"unique\". "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L757-L759","name":"Lean.MetavarContext.addExprMVarDeclExp","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.addExprMVarDeclExp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L736-L755","name":"Lean.MetavarContext.addExprMVarDecl","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.addExprMVarDecl","doc":"Low level API for adding/declaring metavariable declarations.\nIt is used to implement actions in the monads `MetaM`, `ElabM` and `TacticM`.\nIt should not be used directly since the argument `(mvarId : MVarId)` is assumed to be \"unique\". "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L731-L731","name":"Lean.MetavarContext.mkMetavarContext","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.mkMetavarContext","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L728-L728","name":"Lean.MetavarContext.instInhabitedMetavarContext","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.instInhabitedMetavarContext","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L722-L723","name":"Lean.localDeclDependsOnPred","docLink":"./Lean/MetavarContext.html#Lean.localDeclDependsOnPred","doc":"Return true iff the local declaration `localDecl` depends on a free variable `x` s.t. `pf x`, an unassigned metavariable `?m` s.t. `pm ?m` is true. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L718-L719","name":"Lean.dependsOnPred","docLink":"./Lean/MetavarContext.html#Lean.dependsOnPred","doc":"Return true iff `e` depends on a free variable `x` s.t. `pf x`, or an unassigned metavariable `?m` s.t. `pm ?m` is true. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L709-L715","name":"Lean.localDeclDependsOn'","docLink":"./Lean/MetavarContext.html#Lean.localDeclDependsOn'","doc":"Similar to `localDeclDependsOn`, but `x` can be a free variable or an unassigned metavariable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L700-L706","name":"Lean.exprDependsOn'","docLink":"./Lean/MetavarContext.html#Lean.exprDependsOn'","doc":"Similar to `exprDependsOn`, but `x` can be a free variable or an unassigned metavariable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L696-L697","name":"Lean.localDeclDependsOn","docLink":"./Lean/MetavarContext.html#Lean.localDeclDependsOn","doc":"Return true iff `e` depends on the free variable `fvarId` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L692-L693","name":"Lean.dependsOn","docLink":"./Lean/MetavarContext.html#Lean.dependsOn","doc":"Return true iff `e` depends on the free variable `fvarId` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L688-L689","name":"Lean.exprDependsOn","docLink":"./Lean/MetavarContext.html#Lean.exprDependsOn","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L680-L686","name":"Lean.findLocalDeclDependsOn","docLink":"./Lean/MetavarContext.html#Lean.findLocalDeclDependsOn","doc":"Similar to `findExprDependsOn`, but checks the expressions in the given local declaration\ndepends on a free variable `x` s.t. `pf x` is `true` or an unassigned metavariable `?m` s.t. `pm ?m` is true. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L672-L675","name":"Lean.findExprDependsOn","docLink":"./Lean/MetavarContext.html#Lean.findExprDependsOn","doc":"Return `true` iff `e` depends on a free variable `x` s.t. `pf x` is `true`, or an unassigned metavariable `?m` s.t. `pm ?m` is true.\nFor each metavariable `?m` (that does not satisfy `pm` occurring in `x`\n1- If `?m := t`, then we visit `t` looking for `x`\n2- If `?m` is unassigned, then we consider the worst case and check whether `x` is in the local context of `?m`.\n   This case is a \"may dependency\". That is, we may assign a term `t` to `?m` s.t. `t` contains `x`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L661-L662","name":"Lean.DependsOn.main","docLink":"./Lean/MetavarContext.html#Lean.DependsOn.main","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L607-L609","name":"Lean.DependsOn.instMonadMCtxM","docLink":"./Lean/MetavarContext.html#Lean.DependsOn.instMonadMCtxM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L601-L603","name":"Lean.DependsOn.State","docLink":"./Lean/MetavarContext.html#Lean.DependsOn.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L592-L597","name":"Lean.instantiateLocalDeclMVars","docLink":"./Lean/MetavarContext.html#Lean.instantiateLocalDeclMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L586-L590","name":"Lean.instantiateMVarDeclMVars","docLink":"./Lean/MetavarContext.html#Lean.instantiateMVarDeclMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L575-L584","name":"Lean.instantiateLCtxMVars","docLink":"./Lean/MetavarContext.html#Lean.instantiateLCtxMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L567-L573","name":"Lean.instantiateMVars","docLink":"./Lean/MetavarContext.html#Lean.instantiateMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L562-L565","name":"Lean.instantiateMVarsCore","docLink":"./Lean/MetavarContext.html#Lean.instantiateMVarsCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L558-L560","name":"Lean.instMonadMCtxStateRefT'MetavarContextST","docLink":"./Lean/MetavarContext.html#Lean.instMonadMCtxStateRefT'MetavarContextST","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L488-L556","name":"Lean.instantiateExprMVars","docLink":"./Lean/MetavarContext.html#Lean.instantiateExprMVars","doc":"instantiateExprMVars main function "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L472-L485","name":"Lean.instantiateLevelMVars","docLink":"./Lean/MetavarContext.html#Lean.instantiateLevelMVars","doc":"Notes on artificial eta-expanded terms due to metavariables.\nWe try avoid synthetic terms such as `((fun x y => t) a b)` in the output produced by the elaborator.\nThis kind of term may be generated when instantiating metavariable assignments.\nThis module tries to avoid their generation because they often introduce unnecessary dependencies and\nmay affect automation.\n\nWhen elaborating terms, we use metavariables to represent \"holes\". Each hole has a context which includes\nall free variables that may be used to \"fill\" the hole. Suppose, we create a metavariable (hole) `?m : Nat` in a context\ncontaining `(x : Nat) (y : Nat) (b : Bool)`, then we can assign terms such as `x + y` to `?m` since `x` and `y`\nare in the context used to create `?m`. Now, suppose we have the term `?m + 1` and we want to create the lambda expression\n`fun x => ?m + 1`. This term is not correct since we may assign to `?m` a term containing `x`.\nWe address this issue by create a synthetic metavariable `?n : Nat → Nat` and adding the delayed assignment\n`?n #[x] := ?m`, and the term `fun x => ?n x + 1`. When we later assign a term `t[x]` to `?m`, `fun x => t[x]` is assigned to\n`?n`, and if we substitute it at `fun x => ?n x + 1`, we produce `fun x => ((fun x => t[x]) x) + 1`.\nTo avoid this term eta-expanded term, we apply beta-reduction when instantiating metavariable assignments in this module.\nThis operation is performed at `instantiateExprMVars`, `elimMVarDeps`, and `levelMVarToParam`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L451-L452","name":"Lean.assignDelayedMVar","docLink":"./Lean/MetavarContext.html#Lean.assignDelayedMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L448-L449","name":"Lean.assignExprMVar","docLink":"./Lean/MetavarContext.html#Lean.assignExprMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L444-L445","name":"Lean.MVarId.assign","docLink":"./Lean/MetavarContext.html#Lean.MVarId.assign","doc":"Add `mvarId := x` to the metavariable assignment.\nThis method does not check whether `mvarId` is already assigned, nor it checks whether\na cycle is being introduced, or whether the expression has the right type.\nThis is a low-level API, and it is safer to use `isDefEq (mkMVar mvarId) x`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L435-L436","name":"Lean.assignLevelMVar","docLink":"./Lean/MetavarContext.html#Lean.assignLevelMVar","doc":"Add `mvarId := u` to the universe metavariable assignment.\nThis method does not check whether `mvarId` is already assigned, nor it checks whether\na cycle is being introduced.\nThis is a low-level API, and it is safer to use `isLevelDefEq (mkLevelMVar mvarId) u`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L415-L427","name":"Lean.hasAssignableMVar","docLink":"./Lean/MetavarContext.html#Lean.hasAssignableMVar","doc":"Return `true` iff expression contains a metavariable that can be assigned. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L406-L412","name":"Lean.hasAssignableLevelMVar","docLink":"./Lean/MetavarContext.html#Lean.hasAssignableLevelMVar","doc":"Return true iff the given level contains a metavariable that can be assigned. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L391-L403","name":"Lean.hasAssignedMVar","docLink":"./Lean/MetavarContext.html#Lean.hasAssignedMVar","doc":"Return `true` iff expression contains assigned (level/expr) metavariables or delayed assigned mvars "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L382-L388","name":"Lean.hasAssignedLevelMVar","docLink":"./Lean/MetavarContext.html#Lean.hasAssignedLevelMVar","doc":"Return true iff the given level contains an assigned metavariable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L378-L379","name":"Lean.isExprMVarAssignable","docLink":"./Lean/MetavarContext.html#Lean.isExprMVarAssignable","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L372-L375","name":"Lean.MVarId.isAssignable","docLink":"./Lean/MetavarContext.html#Lean.MVarId.isAssignable","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L367-L370","name":"Lean.MetavarContext.getDecl","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.getDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L361-L365","name":"Lean.isLevelMVarAssignable","docLink":"./Lean/MetavarContext.html#Lean.isLevelMVarAssignable","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L358-L359","name":"Lean.isMVarDelayedAssigned","docLink":"./Lean/MetavarContext.html#Lean.isMVarDelayedAssigned","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L354-L355","name":"Lean.MVarId.isDelayedAssigned","docLink":"./Lean/MetavarContext.html#Lean.MVarId.isDelayedAssigned","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L351-L352","name":"Lean.isExprMVarAssigned","docLink":"./Lean/MetavarContext.html#Lean.isExprMVarAssigned","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L347-L348","name":"Lean.MVarId.isAssigned","docLink":"./Lean/MetavarContext.html#Lean.MVarId.isAssigned","doc":"Return `true` if the give metavariable is already assigned. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L343-L344","name":"Lean.isLevelMVarAssigned","docLink":"./Lean/MetavarContext.html#Lean.isLevelMVarAssigned","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L338-L341","name":"Lean.getDelayedMVarRoot","docLink":"./Lean/MetavarContext.html#Lean.getDelayedMVarRoot","doc":"Given a sequence of delayed assignments\n```\nmvarId₁ := mvarId₂ ...;\n...\nmvarIdₙ := mvarId_root ...  -- where `mvarId_root` is not delayed assigned\n```\nin `mctx`, `getDelayedRoot mctx mvarId₁` return `mvarId_root`.\nIf `mvarId₁` is not delayed assigned then return `mvarId₁` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L327-L328","name":"Lean.getDelayedMVarAssignment?","docLink":"./Lean/MetavarContext.html#Lean.getDelayedMVarAssignment?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L324-L325","name":"Lean.getExprMVarAssignment?","docLink":"./Lean/MetavarContext.html#Lean.getExprMVarAssignment?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L321-L322","name":"Lean.MetavarContext.getExprAssignmentCore?","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext.getExprAssignmentCore?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L318-L319","name":"Lean.getLevelMVarAssignment?","docLink":"./Lean/MetavarContext.html#Lean.getLevelMVarAssignment?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L315-L316","name":"Lean.setMCtx","docLink":"./Lean/MetavarContext.html#Lean.setMCtx","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L311-L313","name":"Lean.instMonadMCtx","docLink":"./Lean/MetavarContext.html#Lean.instMonadMCtx","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L305-L307","name":"Lean.MonadMCtx","docLink":"./Lean/MetavarContext.html#Lean.MonadMCtx","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L295-L303","name":"Lean.MetavarContext","docLink":"./Lean/MetavarContext.html#Lean.MetavarContext","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L289-L291","name":"Lean.DelayedMetavarAssignment","docLink":"./Lean/MetavarContext.html#Lean.DelayedMetavarAssignment","doc":"A delayed assignment for a metavariable `?m`. It represents an assignment of the form `?m := (fun fvars => (mkMVar mvarIdPending))`.\n  `mvarIdPending` is a `syntheticOpaque` metavariable that has not been synthesized yet. The delayed assignment becomes a real one\n  as soon as `mvarIdPending` has been fully synthesized.\n  `fvars` are variables in the `mvarIdPending` local context.\n\n  See the comment below `assignDelayedMVar ` for the rationale of delayed assignments.\n\n  Recall that we use a locally nameless approach when dealing with binders. Suppose we are\n  trying to synthesize `?n` in the expression `e`, in the context of `(fun x => e)`.\n  The metavariable `?n` might depend on the bound variable `x`. However, since we are locally nameless,\n  the bound variable `x` is in fact represented by some free variable `fvar_x`. Thus, when we exit\n  the scope, we must rebind the value of `fvar_x` in `?n` to the de-bruijn index of the bound variable `x`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L273-L273","name":"Lean.instInhabitedMetavarDecl","docLink":"./Lean/MetavarContext.html#Lean.instInhabitedMetavarDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L257-L273","name":"Lean.MetavarDecl","docLink":"./Lean/MetavarContext.html#Lean.MetavarDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L253-L255","name":"Lean.MetavarKind.isNatural","docLink":"./Lean/MetavarContext.html#Lean.MetavarKind.isNatural","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L249-L251","name":"Lean.MetavarKind.isSyntheticOpaque","docLink":"./Lean/MetavarContext.html#Lean.MetavarKind.isSyntheticOpaque","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L247-L247","name":"Lean.instReprMetavarKind","docLink":"./Lean/MetavarContext.html#Lean.instReprMetavarKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L247-L247","name":"Lean.instInhabitedMetavarKind","docLink":"./Lean/MetavarContext.html#Lean.instInhabitedMetavarKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L243-L247","name":"Lean.MetavarKind","docLink":"./Lean/MetavarContext.html#Lean.MetavarKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L238-L241","name":"Lean.LocalInstances.erase","docLink":"./Lean/MetavarContext.html#Lean.LocalInstances.erase","doc":"Remove local instance with the given `fvarId`. Do nothing if `localInsts` does not contain any free variable with id `fvarId`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L234-L235","name":"Lean.instBEqLocalInstance","docLink":"./Lean/MetavarContext.html#Lean.instBEqLocalInstance","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L232-L232","name":"Lean.LocalInstances","docLink":"./Lean/MetavarContext.html#Lean.LocalInstances","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L230-L230","name":"Lean.instInhabitedLocalInstance","docLink":"./Lean/MetavarContext.html#Lean.instInhabitedLocalInstance","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/MetavarContext.lean#L227-L230","name":"Lean.LocalInstance","docLink":"./Lean/MetavarContext.html#Lean.LocalInstance","doc":"`LocalInstance` represents a local typeclass instance registered by and for\nthe elaborator. It stores the name of the typeclass in `className`, and the\nconcrete typeclass instance in `fvar`. Note that the kernel does not care about\nthis information, since typeclasses are entirely eliminated during elaboration.\n"}]}