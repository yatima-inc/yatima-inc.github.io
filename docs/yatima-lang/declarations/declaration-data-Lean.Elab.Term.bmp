{"name":"Lean.Elab.Term","instances":[{"typeNames":["Lean.Elab.Term.SyntheticMVarKind"],"name":"Lean.Elab.Term.instInhabitedSyntheticMVarKind","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.SyntheticMVarKind"],"name":"Lean.Elab.Term.instToStringSyntheticMVarKind","className":"ToString"},{"typeNames":["Lean.Elab.Term.SyntheticMVarDecl"],"name":"Lean.Elab.Term.instInhabitedSyntheticMVarDecl","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.MVarErrorKind"],"name":"Lean.Elab.Term.instInhabitedMVarErrorKind","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.MVarErrorKind"],"name":"Lean.Elab.Term.instToStringMVarErrorKind","className":"ToString"},{"typeNames":["Lean.Elab.Term.MVarErrorInfo"],"name":"Lean.Elab.Term.instInhabitedMVarErrorInfo","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.LetRecToLift"],"name":"Lean.Elab.Term.instInhabitedLetRecToLift","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.State"],"name":"Lean.Elab.Term.instInhabitedState","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.State"],"name":"Lean.Elab.Tactic.instInhabitedState","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.Snapshot"],"name":"Lean.Elab.Tactic.instInhabitedSnapshot","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.CacheKey"],"name":"Lean.Elab.Tactic.instBEqCacheKey","className":"BEq"},{"typeNames":["Lean.Elab.Tactic.CacheKey"],"name":"Lean.Elab.Tactic.instHashableCacheKey","className":"Hashable"},{"typeNames":["Lean.Elab.Tactic.CacheKey"],"name":"Lean.Elab.Tactic.instInhabitedCacheKey","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.Cache"],"name":"Lean.Elab.Tactic.instInhabitedCache","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMonadTermElabM","className":"Monad"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instInhabitedTermElabM","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.SavedState"],"name":"Lean.Elab.Term.instInhabitedSavedState","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.SavedState","Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM","className":"Lean.MonadBacktrack"},{"typeNames":["Lean.Elab.Term.TermElabResult"],"name":"Lean.Elab.Term.instInhabitedTermElabResult","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instAddErrorMessageContextTermElabM","className":"Lean.AddErrorMessageContext"},{"typeNames":["Lean.Elab.Term.LVal"],"name":"Lean.Elab.Term.instToStringLVal","className":"ToString"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMonadMacroAdapterTermElabM","className":"Lean.Elab.MonadMacroAdapter"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMetaEvalTermElabM","className":"Lean.MetaEval"}],"imports":["Init","Lean.ResolveName","Lean.Log","Lean.Deprecated","Lean.Util.Sorry","Lean.Util.ReplaceExpr","Lean.Structure","Lean.Meta.AppBuilder","Lean.Meta.CollectMVars","Lean.Meta.Coe","Lean.Hygiene","Lean.Util.RecDepth","Lean.Elab.Config","Lean.Elab.Level","Lean.Elab.Attributes","Lean.Elab.AutoBound","Lean.Elab.InfoTree","Lean.Elab.Open","Lean.Elab.SetOption","Lean.Elab.DeclModifiers"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1835-L1836","name":"Lean.Elab.withoutModifyingStateWithInfoAndMessages","docLink":"./Lean/Elab/Term.html#Lean.Elab.withoutModifyingStateWithInfoAndMessages","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1825-L1830","name":"Lean.Elab.Term.exprToSyntax","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.exprToSyntax","doc":"Helper function for \"embedding\" an `Expr` in `Syntax`.\nIt creates a named hole `?m` and immediately assigns `e` to it.\nExamples:\n```lean\nlet e := mkConst ``Nat.zero\n`(Nat.succ $(← exprToSyntax e))\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1810-L1814","name":"Lean.Elab.Term.expandDeclId","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.expandDeclId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1805-L1808","name":"Lean.Elab.Term.universeConstraintsCheckpoint","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.universeConstraintsCheckpoint","doc":"Execute `x` and then tries to solve pending universe constraints.\nNote that, stuck constraints will not be discarded.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1794-L1799","name":"Lean.Elab.Term.instMetaEvalTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMetaEvalTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1787-L1792","name":"Lean.Elab.Term.TermElabM.toIO","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM.toIO","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1784-L1785","name":"Lean.Elab.Term.TermElabM.run'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM.run'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1781-L1782","name":"Lean.Elab.Term.TermElabM.run","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM.run","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1766-L1778","name":"Lean.Elab.Term.resolveId?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveId?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1757-L1764","name":"Lean.Elab.Term.resolveName'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveName'","doc":"Similar to `resolveName`, but creates identifiers for the main part and each projection with position information derived from `ident`.\nExample: Assume resolveName `v.head.bla.boo` produces `(v.head, [\"bla\", \"boo\"])`, then this method produces\n`(v.head, id, [f₁, f₂])` where `id` is an identifier for `v.head`, and `f₁` and `f₂` are identifiers for fields `\"bla\"` and `\"boo\"`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1743-L1751","name":"Lean.Elab.Term.resolveName.process","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveName.process","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1728-L1751","name":"Lean.Elab.Term.resolveName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1712-L1719","name":"Lean.Elab.Term.mkConst","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkConst","doc":"Create an `Expr.const` using the given name and explicit levels.\nRemark: fresh universe metavariables are created if the constant has more universe\nparameters than `explicitLevels`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1699-L1706","name":"Lean.Elab.Term.isLocalIdent?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isLocalIdent?","doc":"Return true iff `stx` is a `Syntax.ident`, and it is a local variable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1681-L1695","name":"Lean.Elab.Term.resolveLocalName.loop","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveLocalName.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1652-L1657","name":"Lean.Elab.Term.resolveLocalName.go","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveLocalName.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1568-L1696","name":"Lean.Elab.Term.resolveLocalName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveLocalName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1562-L1566","name":"Lean.Elab.Term.isLetRecAuxMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isLetRecAuxMVar","doc":"Return true if mvarId is an auxiliary metavariable created for compiling `let rec` or it\nis delayed assigned to one. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1553-L1556","name":"Lean.Elab.Term.mkAuxName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkAuxName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1546-L1551","name":"Lean.Elab.Term.addAutoBoundImplicits'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addAutoBoundImplicits'","doc":"Similar to `autoBoundImplicits`, but immediately if the resulting array of expressions contains metavariables,\nit immediately use `mkForallFVars` + `forallBoundedTelescope` to convert them into free variables.\nThe type `type` is modified during the process if type depends on `xs`.\nWe use this method to simplify the conversion of code using `autoBoundImplicitsOld` to `autoBoundImplicits`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1526-L1538","name":"Lean.Elab.Term.addAutoBoundImplicits.go","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addAutoBoundImplicits.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1522-L1538","name":"Lean.Elab.Term.addAutoBoundImplicits","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addAutoBoundImplicits","doc":"Return `autoBoundImplicits ++ xs`\n  This methoid throws an error if a variable in `autoBoundImplicits` depends on some `x` in `xs`.\n  The `autoBoundImplicits` may contain free variables created by the auto-implicit feature, and unassigned free variables.\n  It avoids the hack used at `autoBoundImplicitsOld`.\n\n  Remark: we cannot simply replace every occurrence of `addAutoBoundImplicitsOld` with this one because a particular\n  use-case may not be able to handle the metavariables in the array being given to `k`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1496-L1511","name":"Lean.Elab.Term.collectUnassignedMVars.go","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.collectUnassignedMVars.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1488-L1511","name":"Lean.Elab.Term.collectUnassignedMVars","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.collectUnassignedMVars","doc":"Collect unassigned metavariables in `type` that are not already in `init` and not satisfying `except`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1482-L1483","name":"Lean.Elab.Term.withAutoBoundImplicitForbiddenPred","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAutoBoundImplicitForbiddenPred","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1479-L1480","name":"Lean.Elab.Term.withoutAutoBoundImplicit","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutAutoBoundImplicit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1463-L1474","name":"Lean.Elab.Term.withAutoBoundImplicit.loop","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAutoBoundImplicit.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1459-L1477","name":"Lean.Elab.Term.withAutoBoundImplicit","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAutoBoundImplicit","doc":"Enable auto-bound implicits, and execute `k` while catching auto bound implicit exceptions. When an exception is caught,\na new local declaration is created, registered, and `k` is tried to be executed again. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1451-L1454","name":"Lean.Elab.Term.elabType","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabType","doc":"Elaborate `stx` and ensure result is a type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1439-L1448","name":"Lean.Elab.Term.ensureType","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureType","doc":"Make sure `e` is a type by inferring its type and making sure it is a `Expr.sort`\nor is unifiable with `Expr.sort`, or can be coerced into one. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1403-L1408","name":"Lean.Elab.Term.mkInstMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkInstMVar","doc":"Create a new metavariable with the given type, and try to synthesize it.\nIt type class resolution cannot be executed (e.g., it is stuck because of metavariables in `type`),\nregister metavariable as a pending one.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1394-L1396","name":"Lean.Elab.Term.adaptExpander","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.adaptExpander","doc":"Adapt a syntax transformation to a regular, term-producing elaborator. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1378-L1391","name":"Lean.Elab.Term.commitIfNoErrors?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.commitIfNoErrors?","doc":"Execute `x` and return `some` if no new errors were recorded or exceptions was thrown. Otherwise, return `none` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1373-L1375","name":"Lean.Elab.Term.elabTermEnsuringType","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabTermEnsuringType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1370-L1371","name":"Lean.Elab.Term.elabTerm","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabTerm","doc":"Main function for elaborating terms.\n  It extracts the elaboration methods from the environment using the node kind.\n  Recall that the environment has a mapping from `SyntaxNodeKind` to `TermElab` methods.\n  It creates a fresh macro scope for executing the elaboration method.\n  All unlogged trace messages produced by the elaboration method are logged using\n  the position information at `stx`. If the elaboration method throws an `Exception.error` and `errToSorry == true`,\n  the error is logged and a synthetic sorry expression is returned.\n  If the elaboration throws `Exception.postpone` and `catchExPostpone == true`,\n  a new synthetic metavariable of kind `SyntheticMVarKind.postponed` is created, registered,\n  and returned.\n  The option `catchExPostpone == false` is used to implement `resumeElabTerm`\n  to prevent the creation of another synthetic metavariable when resuming the elaboration.\n\n  If `implicitLambda == true`, then disable implicit lambdas feature for the given syntax, but not for its subterms.\n  We use this flag to implement, for example, the `@` modifier. If `Context.implicitLambda == false`, then this parameter has no effect.\n  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1350-L1351","name":"Lean.Elab.Term.addDotCompletionInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addDotCompletionInfo","doc":"Store in the `InfoTree` that `e` is a \"dot\"-completion target. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1258-L1262","name":"Lean.Elab.Term.blockImplicitLambda","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.blockImplicitLambda","doc":"Block usage of implicit lambdas if `stx` is `@f` or `@f arg1 ...` or `fun` with an implicit binder annotation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1251-L1255","name":"Lean.Elab.Term.mkNoImplicitLambdaAnnotation","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkNoImplicitLambdaAnnotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1248-L1249","name":"Lean.Elab.Term.hasNoImplicitLambdaAnnotation","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.hasNoImplicitLambdaAnnotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1200-L1203","name":"Lean.Elab.Term.instMonadMacroAdapterTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMonadMacroAdapterTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1138-L1140","name":"Lean.Elab.Term.postponeElabTerm","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.postponeElabTerm","doc":"Postpone the elaboration of `stx`, return a metavariable that acts as a placeholder, and\nensures the info tree is updated and a hole id is introduced.\nWhen `stx` is elaborated, new info nodes are created and attached to the new hole id in the info tree.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1126-L1131","name":"Lean.Elab.Term.withInfoContext'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withInfoContext'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1123-L1124","name":"Lean.Elab.Term.addTermInfo'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addTermInfo'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1116-L1121","name":"Lean.Elab.Term.addTermInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addTermInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1109-L1114","name":"Lean.Elab.Term.mkTermInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTermInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1100-L1107","name":"Lean.Elab.Term.isTacticOrPostponedHole?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isTacticOrPostponedHole?","doc":"Return `some mvarId` if `e` corresponds to a hole that is going to be filled \"later\" by executing a tactic or resuming elaboration.\n\n  We do not save `ofTermInfo` for this kind of node in the `InfoTree`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1090-L1093","name":"Lean.Elab.Term.removeSaveInfoAnnotation","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.removeSaveInfoAnnotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1087-L1088","name":"Lean.Elab.Term.isSaveInfoAnnotation?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isSaveInfoAnnotation?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1081-L1085","name":"Lean.Elab.Term.mkSaveInfoAnnotation","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkSaveInfoAnnotation","doc":"Create an auxiliary annotation to make sure we create a `Info` even if `e` is a metavariable.\n  See `mkTermInfo`.\n\n  We use this functions because some elaboration functions elaborate subterms that may not be immediately\n  part of the resulting term. Example:\n  ```\n  let_mvar% ?m := b; wait_if_type_mvar% ?m; body\n  ```\n  If the type of `b` is not known, then `wait_if_type_mvar% ?m; body` is postponed and just return a fresh\n  metavariable `?n`. The elaborator for\n  ```\n  let_mvar% ?m := b; wait_if_type_mvar% ?m; body\n  ```\n  returns `mkSaveInfoAnnotation ?n` to make sure the info nodes created when elaborating `b` are \"saved\".\n  This is a bit hackish, but elaborators like `let_mvar%` are rare.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1061-L1062","name":"Lean.Elab.Term.getSyntheticMVarDecl?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getSyntheticMVarDecl?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1045-L1048","name":"Lean.Elab.Term.withSavedContext","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withSavedContext","doc":"Execute `x` with the context saved using `saveContext`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1032-L1040","name":"Lean.Elab.Term.saveContext","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.saveContext","doc":"Save relevant context for term elaboration postponement.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1024-L1027","name":"Lean.Elab.Term.tryPostponeIfHasMVars","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfHasMVars","doc":"Throws `Exception.postpone`, if `expectedType?` contains unassigned metavariables.\nIf `mayPostpone == false`, it throws error `msg`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1011-L1018","name":"Lean.Elab.Term.tryPostponeIfHasMVars?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfHasMVars?","doc":"Throws `Exception.postpone`, if `expectedType?` contains unassigned metavariables.\nIt is a noop if `mayPostpone == false`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L1002-L1005","name":"Lean.Elab.Term.tryPostponeIfNoneOrMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfNoneOrMVar","doc":"If `e? = some e`, then `tryPostponeIfMVar e`, otherwise it is just `tryPostpone`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L997-L999","name":"Lean.Elab.Term.tryPostponeIfMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfMVar","doc":"If `mayPostpone == true` and `e`'s head is a metavariable, throw `Exception.postpone`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L993-L994","name":"Lean.Elab.Term.isMVarApp","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isMVarApp","doc":"Return `true` if `e` reduces (by unfolding only `[reducible]` declarations) to `?m ...` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L988-L990","name":"Lean.Elab.Term.tryPostpone","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostpone","doc":"If `mayPostpone == true`, throw `Expection.postpone`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L982-L985","name":"Lean.Elab.Term.exceptionToSorry","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.exceptionToSorry","doc":"Log the given exception, and create an synthetic sorry for representing the failed\nelaboration step with exception `ex`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L961-L966","name":"Lean.Elab.Term.ensureHasType","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureHasType","doc":"If `expectedType?` is `some t`, then ensure `t` and type of `e` are definitionally equal.\nIf they are not, then try coercions. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L948-L956","name":"Lean.Elab.Term.ensureHasTypeAux","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureHasTypeAux","doc":"If `expectedType?` is `some t`, then ensure `t` and `eType` are definitionally equal.\n  If they are not, then try coercions.\n\n  Argument `f?` is used only for generating error messages. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L840-L842","name":"Lean.Elab.Term.isMonadApp","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isMonadApp","doc":"Return `true` if `type` is of the form `m α` where `m` is a `Monad`.\nNote that we reduce `type` using transparency `[reducible]`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L821-L825","name":"Lean.Elab.Term.isTypeApp?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isTypeApp?","doc":"Return `some (m, α)` if `type` can be reduced to an application of the form `m α` using `[reducible]` transparency. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L784-L803","name":"Lean.Elab.Term.mkCoe","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkCoe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L774-L782","name":"Lean.Elab.Term.tryCoeThunk?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryCoeThunk?","doc":"The coercion from `α` to `Thunk α` cannot be implemented using an instance because it would\neagerly evaluate `e`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L767-L768","name":"Lean.Elab.Term.synthesizeCoeInstMVarCore","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.synthesizeCoeInstMVarCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L762-L762","name":"Lean.Elab.Term.maxCoeSize","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.maxCoeSize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L757-L757","name":"Lean.Elab.Term.autoLift","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.autoLift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L711-L755","name":"Lean.Elab.Term.synthesizeInstMVarCore","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.synthesizeInstMVarCore","doc":"Try to synthesize metavariable using type class resolution.\nThis method assumes the local context and local instances of `instMVar` coincide\nwith the current local context and local instances.\nReturn `true` if the instance was synthesized successfully, and `false` if\nthe instance contains unassigned metavariables that are blocking the type class\nresolution procedure. Throw an exception if resolution or assignment irrevocably fails.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L698-L701","name":"Lean.Elab.Term.containsPendingMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.containsPendingMVar","doc":"Return `true` if `e` contains a pending metavariable. Remark: it also visits let-declarations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L672-L693","name":"Lean.Elab.Term.ContainsPendingMVar.visit","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ContainsPendingMVar.visit","doc":"See `containsPostponedTerm` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L669-L669","name":"Lean.Elab.Term.ContainsPendingMVar.M","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ContainsPendingMVar.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L664-L665","name":"Lean.Elab.Term.withoutMacroStackAtErr","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutMacroStackAtErr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L643-L662","name":"Lean.Elab.Term.throwTypeMismatchError","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.throwTypeMismatchError","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L637-L641","name":"Lean.Elab.Term.mkTypeMismatchError","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTypeMismatchError","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L634-L635","name":"Lean.Elab.Term.applyAttributes","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.applyAttributes","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L631-L632","name":"Lean.Elab.Term.applyAttributesAt","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.applyAttributesAt","doc":"Apply given attributes **at** a given application time "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L612-L613","name":"Lean.Elab.Term.mkFreshIdent","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkFreshIdent","doc":"Auxiliary method for creating a `Syntax.ident` containing\na fresh name. This method is intended for creating fresh binder names.\nIt is just a thin layer on top of `mkFreshUserName`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L605-L606","name":"Lean.Elab.Term.mkFreshBinderName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkFreshBinderName","doc":"Auxiliary method for creating fresh binder names.\nDo not confuse with the method for creating fresh free/meta variable ids. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L596-L600","name":"Lean.Elab.Term.levelMVarToParam'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.levelMVarToParam'","doc":"Variant of `levelMVarToParam` where `nextParamIdx` is stored in a state monad. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L589-L593","name":"Lean.Elab.Term.levelMVarToParam","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.levelMVarToParam","doc":"Convert unassigned universe level metavariables into parameters.\n  The new parameter names are of the form `u_i` where `i >= nextParamIdx`.\n  The method returns the updated expression and new `nextParamIdx`.\n\n  Remark: we make sure the generated parameter names do not clash with the universe at `ctx.levelNames`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L580-L581","name":"Lean.Elab.Term.mkExplicitBinder","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkExplicitBinder","doc":"Creates syntax for `(` <ident> `:` <type> `)` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L576-L577","name":"Lean.Elab.Term.withoutPostponing","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutPostponing","doc":"Execute `x` without allowing it to postpone elaboration tasks.\nThat is, `tryPostpone` is a noop. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L568-L571","name":"Lean.Elab.Term.ensureNoUnassignedMVars","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureNoUnassignedMVars","doc":"Ensure metavariables registered using `registerMVarErrorInfos` (and used in the given declaration) have been assigned. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L541-L565","name":"Lean.Elab.Term.logUnassignedUsingErrorInfos","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.logUnassignedUsingErrorInfos","doc":"Try to log errors for the unassigned metavariables `pendingMVarIds`.\n\n  Return `true` if there were \"unfilled holes\", and we should \"abort\" declaration.\n  TODO: try to fill \"all\" holes using synthetic \"sorry's\"\n\n  Remark: We only log the \"unfilled holes\" as new errors if no error has been logged so far. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L529-L532","name":"Lean.Elab.Term.MVarErrorInfo.logError.appendExtra","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.logError.appendExtra","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L524-L527","name":"Lean.Elab.Term.MVarErrorInfo.logError.addArgName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.logError.addArgName","doc":"Append `mvarErrorInfo` argument name (if available) to the message.\nRemark: if the argument name contains macro scopes we do not append it. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L508-L532","name":"Lean.Elab.Term.MVarErrorInfo.logError","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.logError","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L502-L506","name":"Lean.Elab.Term.throwMVarError","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.throwMVarError","doc":"Auxiliary method for reporting errors of the form \"... contains metavariables ...\".\nThis kind of error is thrown, for example, at `Match.lean` where elaboration\ncannot continue if there are metavariables in patterns.\nWe only want to log it if we haven't logged any error so far. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L492-L495","name":"Lean.Elab.Term.registerCustomErrorIfMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerCustomErrorIfMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L489-L490","name":"Lean.Elab.Term.getMVarErrorInfo?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getMVarErrorInfo?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L486-L487","name":"Lean.Elab.Term.registerMVarErrorCustomInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorCustomInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L483-L484","name":"Lean.Elab.Term.registerMVarErrorImplicitArgInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorImplicitArgInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L480-L481","name":"Lean.Elab.Term.registerMVarErrorHoleInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorHoleInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L477-L478","name":"Lean.Elab.Term.registerMVarErrorInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L474-L475","name":"Lean.Elab.Term.registerSyntheticMVarWithCurrRef","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerSyntheticMVarWithCurrRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L471-L472","name":"Lean.Elab.Term.registerSyntheticMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerSyntheticMVar","doc":"Add the given metavariable to the list of pending synthetic metavariables.\nThe method `synthesizeSyntheticMVars` is used to process the metavariables on this list. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L464-L466","name":"Lean.Elab.Term.withMacroExpansion","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withMacroExpansion","doc":"Elaborate `x` with `stx` on the macro stack "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L460-L461","name":"Lean.Elab.Term.elabLevel","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabLevel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L451-L458","name":"Lean.Elab.Term.liftLevelM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.liftLevelM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L446-L447","name":"Lean.Elab.Term.ppGoal","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ppGoal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L443-L444","name":"Lean.Elab.Term.traceAtCmdPos","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.traceAtCmdPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L439-L441","name":"Lean.Elab.Term.throwErrorIfErrors","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.throwErrorIfErrors","doc":"For testing `TermElabM` methods. The #eval command will sign the error. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L435-L436","name":"Lean.Elab.Term.withoutErrToSorry","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutErrToSorry","doc":"Execute `x` without converting errors (i.e., exceptions) to `sorry` applications.\nRecall that when `errToSorry = true`, the method `elabTerm` catches exceptions and convert them into `sorry` applications.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L428-L429","name":"Lean.Elab.Term.withoutErrToSorryImp","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutErrToSorryImp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L423-L426","name":"Lean.Elab.Term.withAuxDecl","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAuxDecl","doc":"Declare an auxiliary local declaration `shortDeclName : type` for elaborating recursive declaration `declName`,\nupdate the mapping `auxDeclToFullName`, and then execute `k`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L414-L417","name":"Lean.Elab.Term.withLevelNames","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withLevelNames","doc":"Execute `x` using `levelNames` as the universe level parameter names. See `getLevelNames`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L410-L411","name":"Lean.Elab.Term.setLevelNames","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.setLevelNames","doc":"Update the universe level parameter names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L406-L407","name":"Lean.Elab.Term.withDeclName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withDeclName","doc":"Execute `x` with `declName? := name`. See `getDeclName? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L403-L403","name":"Lean.Elab.Term.getMVarDecl","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getMVarDecl","doc":"Return the declaration of the given metavariable "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L401-L401","name":"Lean.Elab.Term.getLetRecsToLift","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getLetRecsToLift","doc":"Return the list of nested `let rec` declarations that need to be lifted. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L399-L399","name":"Lean.Elab.Term.getDeclName?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getDeclName?","doc":"Return the name of the declaration being elaborated if available. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L393-L396","name":"Lean.Elab.Term.instToStringLVal","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instToStringLVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L389-L391","name":"Lean.Elab.Term.LVal.isFieldName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal.isFieldName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L385-L387","name":"Lean.Elab.Term.LVal.getRef","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal.getRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L379-L383","name":"Lean.Elab.Term.LVal","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal","doc":"Auxiliary datatatype for presenting a Lean lvalue modifier.\nWe represent a unelaborated lvalue as a `Syntax` (or `Expr`) and `List LVal`.\nExample: `a.foo.1` is represented as the `Syntax` `a` and the list\n`[LVal.fieldName \"foo\", LVal.fieldIdx 1]`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L371-L371","name":"Lean.Elab.Term.termElabAttribute","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.termElabAttribute","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L369-L369","name":"Lean.Elab.Term.mkTermElabAttribute","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTermElabAttribute","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L365-L366","name":"Lean.Elab.Term.mkTermElabAttributeUnsafe","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTermElabAttributeUnsafe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L362-L363","name":"Lean.Elab.Term.withoutSavingRecAppSyntax","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutSavingRecAppSyntax","doc":"Execute `x` without storing `Syntax` for recursive applications. See `saveRecAppSyntax` field at `Context`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L339-L346","name":"Lean.Elab.Term.withoutModifyingElabMetaStateWithInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutModifyingElabMetaStateWithInfo","doc":"Execute `x` but discard changes performed at `Term.State` and `Meta.State`.\nRecall that the `Environment` and `InfoState` are at `Core.State`. Thus, any updates to it will\nbe preserved. This method is useful for performing computations where all\nmetavariable must be resolved or discarded.\nThe `InfoTree`s are not discarded, however, and wrapped in `InfoTree.Context`\nto store their metavariable context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L324-L330","name":"Lean.Elab.Term.instAddErrorMessageContextTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instAddErrorMessageContextTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L319-L322","name":"Lean.Elab.Term.getFVarLocalDecl!","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getFVarLocalDecl!","doc":"Given a free variable `fvar`, return its declaration.\nThis function panics if `fvar` is not a free variable.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L312-L313","name":"Lean.Elab.Term.getLevelNames","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getLevelNames","doc":"Return the universe level names explicitly provided by the user.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L304-L307","name":"Lean.Elab.Term.commitIfDidNotPostpone","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.commitIfDidNotPostpone","doc":"Execute `x`, but keep state modifications only if `x` did not postpone.\nThis method is useful to implement elaboration functions that cannot decide whether\nthey need to postpone or not without updating the state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L295-L298","name":"Lean.Elab.Term.applyResult","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.applyResult","doc":"Apply the result/exception and state captured with `observing`.\nWe use this method to implement overloaded notation and symbols. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L275-L290","name":"Lean.Elab.Term.observing","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.observing","doc":"Execute `x`, save resulting expression and new state.\nWe remove any `Info` created by `x`.\nThe info nodes are committed when we execute `applyResult`.\nWe use `observing` to implement overloaded notation and decls.\nWe want to save `Info` nodes for the chosen alternative.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L265-L266","name":"Lean.Elab.Term.instInhabitedTermElabResult","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedTermElabResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L263-L263","name":"Lean.Elab.Term.TermElabResult","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L259-L261","name":"Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L250-L257","name":"Lean.Elab.Term.SavedState.restore","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedState.restore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L247-L248","name":"Lean.Elab.Term.saveState","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.saveState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L245-L245","name":"Lean.Elab.Term.instInhabitedSavedState","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedSavedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L242-L245","name":"Lean.Elab.Term.SavedState","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedState","doc":"Backtrackable state for the `TermElabM` monad.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L236-L237","name":"Lean.Elab.Term.instInhabitedTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L232-L232","name":"Lean.Elab.Term.instMonadTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMonadTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L228-L228","name":"Lean.Elab.Term.TermElab","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElab","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L227-L227","name":"Lean.Elab.Term.TermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L170-L225","name":"Lean.Elab.Term.Context","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L164-L164","name":"Lean.Elab.Tactic.instInhabitedCache","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedCache","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L161-L164","name":"Lean.Elab.Tactic.Cache","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Cache","doc":"Cache for the `save` tactic.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L156-L156","name":"Lean.Elab.Tactic.instInhabitedCacheKey","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedCacheKey","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L156-L156","name":"Lean.Elab.Tactic.instHashableCacheKey","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instHashableCacheKey","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L156-L156","name":"Lean.Elab.Tactic.instBEqCacheKey","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instBEqCacheKey","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L153-L156","name":"Lean.Elab.Tactic.CacheKey","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.CacheKey","doc":"Key for the cache used to implement the `save` tactic.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L148-L148","name":"Lean.Elab.Tactic.instInhabitedSnapshot","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedSnapshot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L142-L148","name":"Lean.Elab.Tactic.Snapshot","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Snapshot","doc":"Snapshots are used to implement the `save` tactic.\nThis tactic caches the state of the system, and allows us to \"replay\"\nexpensive proofs efficiently. This is only relevant implementing the\nLSP server.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L134-L134","name":"Lean.Elab.Tactic.instInhabitedState","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L132-L134","name":"Lean.Elab.Tactic.State","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.State","doc":"State of the `TacticM` monad.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L123-L123","name":"Lean.Elab.Term.instInhabitedState","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L117-L123","name":"Lean.Elab.Term.State","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.State","doc":"State of the `TermElabM` monad.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L112-L112","name":"Lean.Elab.Term.instInhabitedLetRecToLift","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedLetRecToLift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L101-L112","name":"Lean.Elab.Term.LetRecToLift","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift","doc":"Nested `let rec` expressions are eagerly lifted by the elaborator.\nWe store the information necessary for performing the lifting here.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L95-L95","name":"Lean.Elab.Term.instInhabitedMVarErrorInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedMVarErrorInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L90-L95","name":"Lean.Elab.Term.MVarErrorInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo","doc":"We can optionally associate an error context with metavariables.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L81-L85","name":"Lean.Elab.Term.instToStringMVarErrorKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instToStringMVarErrorKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L79-L79","name":"Lean.Elab.Term.instInhabitedMVarErrorKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedMVarErrorKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L72-L79","name":"Lean.Elab.Term.MVarErrorKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorKind","doc":"We can optionally associate an error context with a metavariable (see `MVarErrorInfo`).\nWe have three different kinds of error context.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L66-L66","name":"Lean.Elab.Term.instInhabitedSyntheticMVarDecl","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedSyntheticMVarDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L63-L66","name":"Lean.Elab.Term.SyntheticMVarDecl","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L56-L61","name":"Lean.Elab.Term.instToStringSyntheticMVarKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instToStringSyntheticMVarKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L54-L54","name":"Lean.Elab.Term.instInhabitedSyntheticMVarKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedSyntheticMVarKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L41-L54","name":"Lean.Elab.Term.SyntheticMVarKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarKind","doc":"We use synthetic metavariables as placeholders for pending elaboration steps. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Term.lean#L32-L38","name":"Lean.Elab.Term.SavedContext","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedContext","doc":"Saved context for postponed terms and tactics to be executed. "}]}