{"name":"Lean.ResolveName","instances":[{"typeNames":[],"name":"Lean.instMonadResolveName","className":"Lean.MonadResolveName"}],"imports":["Init","Lean.Data.OpenDecl","Lean.Hygiene","Lean.Modifiers","Lean.Exception"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L283-L287","name":"Lean.resolveGlobalConstNoOverload","docLink":"./Lean/ResolveName.html#Lean.resolveGlobalConstNoOverload","doc":"Interpret the syntax `n` as an identifier for a global constant, and return a resolved\nconstant name. If there are multiple possible interpretations it will throw.\n\n## Example:\n```\ndef Boo.x   := 1\ndef Foo.x   := 2\ndef Foo.x.y := 3\n```\nAfter `open Foo`, we have\n- `resolveGlobalConstNoOverload x`     => `Foo.x`\n- `resolveGlobalConstNoOverload x.y`   => `Foo.x.y`\n- `resolveGlobalConstNoOverload x.z.w` => error: unknown constant\n\nAfter `open Foo open Boo`, we have\n- `resolveGlobalConstNoOverload x`     => error: ambiguous identifier\n- `resolveGlobalConstNoOverload x.y`   => `Foo.x.y`\n- `resolveGlobalConstNoOverload x.z.w` => error: unknown constant\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L255-L262","name":"Lean.resolveGlobalConst","docLink":"./Lean/ResolveName.html#Lean.resolveGlobalConst","doc":"Interpret the syntax `n` as an identifier for a global constant, and return a list of resolved\nconstant names that it could be refering to based on the currently open namespaces.\nThis should be used instead of `resolveGlobalConstCore` for identifiers taken from syntax\nbecause `Syntax` objects may have names that have already been resolved.\n\n## Example:\n```\ndef Boo.x   := 1\ndef Foo.x   := 2\ndef Foo.x.y := 3\n```\nAfter `open Foo`, we have\n- `resolveGlobalConst x`     => `[Foo.x]`\n- `resolveGlobalConst x.y`   => `[Foo.x.y]`\n- `resolveGlobalConst x.z.w` => error: unknown constant\n\nAfter `open Foo open Boo`, we have\n- `resolveGlobalConst x`     => `[Foo.x, Boo.x]`\n- `resolveGlobalConst x.y`   => `[Foo.x.y]`\n- `resolveGlobalConst x.z.w` => error: unknown constant\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L228-L232","name":"Lean.resolveGlobalConstNoOverloadCore","docLink":"./Lean/ResolveName.html#Lean.resolveGlobalConstNoOverloadCore","doc":"For identifiers taken from syntax, use `resolveGlobalConstNoOverload` instead, which respects preresolved names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L221-L225","name":"Lean.resolveGlobalConstCore","docLink":"./Lean/ResolveName.html#Lean.resolveGlobalConstCore","doc":"Given a name `n`, return a list of possible interpretations for global constants.\n\nSimilar to `resolveGlobalName`, but discard any candidate whose `fieldList` is not empty.\nFor identifiers taken from syntax, use `resolveGlobalConst` instead, which respects preresolved names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L212-L215","name":"Lean.resolveUniqueNamespace","docLink":"./Lean/ResolveName.html#Lean.resolveUniqueNamespace","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L207-L210","name":"Lean.resolveNamespace","docLink":"./Lean/ResolveName.html#Lean.resolveNamespace","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L204-L205","name":"Lean.resolveGlobalName","docLink":"./Lean/ResolveName.html#Lean.resolveGlobalName","doc":"Given a name `n`, return a list of possible interpretations.\n  Each interpretation is a pair `(declName, fieldList)`, where `declName`\n  is the name of a declaration in the current environment, and `fieldList` are\n  (potential) field names.\n  The pair is needed because in Lean `.` may be part of a qualified name or\n  a field (aka dot-notation).\n  As an example, consider the following definitions\n  ```\n  def Boo.x   := 1\n  def Foo.x   := 2\n  def Foo.x.y := 3\n  ```\n  After `open Foo`, we have\n  - `resolveGlobalName x`     => `[(Foo.x, [])]`\n  - `resolveGlobalName x.y`   => `[(Foo.x.y, [])]`\n  - `resolveGlobalName x.z.w` => `[(Foo.x, [z, w])]`\n\n  After `open Foo open Boo`, we have\n  - `resolveGlobalName x`     => `[(Foo.x, []), (Boo.x, [])]`\n  - `resolveGlobalName x.y`   => `[(Foo.x.y, [])]`\n  - `resolveGlobalName x.z.w` => `[(Foo.x, [z, w]), (Boo.x, [z, w])]`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L177-L179","name":"Lean.instMonadResolveName","docLink":"./Lean/ResolveName.html#Lean.instMonadResolveName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L171-L173","name":"Lean.MonadResolveName","docLink":"./Lean/ResolveName.html#Lean.MonadResolveName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L164-L167","name":"Lean.ResolveName.resolveNamespace","docLink":"./Lean/ResolveName.html#Lean.ResolveName.resolveNamespace","doc":"Given a name `id` try to find namespaces it may refer to. The resolution procedure works as follows\n\n1- If `id` is in the scope of `namespace` commands the namespace `s_1. ... . s_n`,\n   then we include `s_1 . ... . s_i ++ n` in the result if it is the name of an existing namespace.\n   We search \"backwards\", and include at most one of the in the list of resulting namespaces.\n\n2- If `id` is the extact name of an existing namespace, then include `id`\n\n3- Finally, for each command `open N`, include in the result `N ++ n` if it is the name of an existing namespace.\n   We only consider simple `open` commands. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L148-L151","name":"Lean.ResolveName.resolveNamespaceUsingOpenDecls","docLink":"./Lean/ResolveName.html#Lean.ResolveName.resolveNamespaceUsingOpenDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L143-L146","name":"Lean.ResolveName.resolveNamespaceUsingScope?","docLink":"./Lean/ResolveName.html#Lean.ResolveName.resolveNamespaceUsingScope?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L119-L138","name":"Lean.ResolveName.resolveGlobalName.loop","docLink":"./Lean/ResolveName.html#Lean.ResolveName.resolveGlobalName.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L116-L139","name":"Lean.ResolveName.resolveGlobalName","docLink":"./Lean/ResolveName.html#Lean.ResolveName.resolveGlobalName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L53-L54","name":"Lean.getRevAliases","docLink":"./Lean/ResolveName.html#Lean.getRevAliases","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L43-L50","name":"Lean.getAliases","docLink":"./Lean/ResolveName.html#Lean.getAliases","doc":"Retrieve aliases for `a`. If `skipProtected` is `true`, then the resulting list only includes\ndeclarations that are not marked as `proctected`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L36-L37","name":"Lean.getAliasState","docLink":"./Lean/ResolveName.html#Lean.getAliasState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L33-L34","name":"Lean.addAlias","docLink":"./Lean/ResolveName.html#Lean.addAlias","doc":"Add alias `a` for `e` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L25-L25","name":"Lean.aliasExtension","docLink":"./Lean/ResolveName.html#Lean.aliasExtension","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L20-L23","name":"Lean.addAliasEntry","docLink":"./Lean/ResolveName.html#Lean.addAliasEntry","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L18-L18","name":"Lean.AliasEntry","docLink":"./Lean/ResolveName.html#Lean.AliasEntry","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/ResolveName.lean#L17-L17","name":"Lean.AliasState","docLink":"./Lean/ResolveName.html#Lean.AliasState","doc":""}]}