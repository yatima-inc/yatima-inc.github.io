{"name":"Lean.Elab.Quotation","instances":[],"imports":["Init","Lean.Syntax","Lean.ResolveName","Lean.Elab.Term","Lean.Elab.Quotation.Util","Lean.Elab.Quotation.Precheck","Lean.Parser.Term"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L643-L646","name":"Lean.Elab.Term.Quotation.elabNoErrorIfUnused","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.elabNoErrorIfUnused","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L640-L641","name":"Lean.Elab.Term.Quotation.elabMatchSyntax","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.elabMatchSyntax","doc":"Syntactic pattern match. Matches a `Syntax` value against quotations, pattern variables, or `_`.\n\n  Quoted identifiers only match identical identifiers - custom matching such as by the preresolved names only should be done explicitly.\n\n  `Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\n  For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they should participate in matching.\n  For example, in\n  ```lean\n  syntax \"c\" (\"foo\" <|> \"bar\") ...\n  ```\n  `foo` and `bar` are indistinguishable during matching, but in\n  ```lean\n  syntax foo := \"foo\"\n  syntax \"c\" (foo <|> \"bar\") ...\n  ```\n  they are not. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L608-L621","name":"Lean.Elab.Term.Quotation.match_syntax.expand","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.match_syntax.expand","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L548-L548","name":"Lean.Elab.Term.Quotation.IdxSet","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.IdxSet","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L280-L286","name":"Lean.Elab.Term.Quotation.HeadInfo","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.HeadInfo","doc":"All necessary information on a pattern head. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L268-L275","name":"Lean.Elab.Term.Quotation.MatchResult","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.MatchResult","doc":"Describe whether a pattern is covered by a head check (induced by the pattern itself or a different pattern). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L246-L263","name":"Lean.Elab.Term.Quotation.HeadCheck","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.HeadCheck","doc":"In a single match step, we match the first discriminant against the \"head\" of the first pattern of the first\nalternative. This datatype describes what kind of check this involves, which helps other patterns decide if\nthey are covered by the same check and don't have to be checked again (see also `MatchResult`). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L217-L217","name":"Lean.Elab.Term.Quotation.commandElab_stx_quot_","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.commandElab_stx_quot_","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L189-L200","name":"Lean.Elab.Term.Quotation.stxQuot.expand","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.stxQuot.expand","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L170-L187","name":"Lean.Elab.Term.Quotation.getQuotKind","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.getQuotKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L88-L89","name":"Lean.Elab.Term.Quotation.ArrayStxBuilder.append","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.ArrayStxBuilder.append","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L83-L86","name":"Lean.Elab.Term.Quotation.ArrayStxBuilder.push","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.ArrayStxBuilder.push","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L79-L81","name":"Lean.Elab.Term.Quotation.ArrayStxBuilder.build","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.ArrayStxBuilder.build","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L77-L77","name":"Lean.Elab.Term.Quotation.ArrayStxBuilder.empty","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.ArrayStxBuilder.empty","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L73-L73","name":"Lean.Elab.Term.Quotation.ArrayStxBuilder","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.ArrayStxBuilder","doc":"Transform sequence of pushes and appends into acceptable code "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L62-L69","name":"Lean.Elab.Term.Quotation.resolveSectionVariable.loop","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.resolveSectionVariable.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L59-L70","name":"Lean.Elab.Term.Quotation.resolveSectionVariable","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.resolveSectionVariable","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Quotation.lean#L52-L57","name":"Lean.Elab.Term.Quotation.mkTuple","docLink":"./Lean/Elab/Quotation.html#Lean.Elab.Term.Quotation.mkTuple","doc":""}]}