{"name":"Lean.LazyInitExtension","instances":[{"typeNames":["Lean.LazyInitExtension"],"name":"Lean.instInhabitedLazyInitExtension","className":"Inhabited"}],"imports":["Init","Lean.MonadEnv"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/LazyInitExtension.lean#L33-L39","name":"Lean.LazyInitExtension.get","docLink":"./Lean/LazyInitExtension.html#Lean.LazyInitExtension.get","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/LazyInitExtension.lean#L29-L31","name":"Lean.registerLazyInitExtension","docLink":"./Lean/LazyInitExtension.html#Lean.registerLazyInitExtension","doc":"Register an environment extension for storing the result of `fn`.\n  We initialize the extension with `none`, and `fn` is executed the\n  first time `LazyInit.get` is executed.\n\n  This kind of extension is useful for avoiding work duplication in\n  scenarios where a thunk cannot be used because the computation depends\n  on state from the `m` monad. For example, we may want to \"cache\" a collection\n  of theorems as a `SimpLemmas` object.  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/LazyInitExtension.lean#L14-L18","name":"Lean.instInhabitedLazyInitExtension","docLink":"./Lean/LazyInitExtension.html#Lean.instInhabitedLazyInitExtension","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/LazyInitExtension.lean#L10-L12","name":"Lean.LazyInitExtension","docLink":"./Lean/LazyInitExtension.html#Lean.LazyInitExtension","doc":""}]}