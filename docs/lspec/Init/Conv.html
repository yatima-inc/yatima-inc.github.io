<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="stylesheet" href=".././src/pygments.css"></link><link rel="shortcut icon" href=".././favicon.ico"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.Conv</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.Conv";</script><script type="module" src=".././nav.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within">Init.Conv</p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib_docs"></input><input type="text" name="q" autocomplete="off"></input><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top">Init.Conv</a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init/NotationExtra.html">Init.NotationExtra</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Conv" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.conv.quot">Lean.Parser.Tactic.Conv.conv.quot</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.conv">Lean.Parser.Category.conv</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convSeq1Indented">Lean.Parser.Tactic.Conv.convSeq1Indented</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convSeqBracketed">Lean.Parser.Tactic.Conv.convSeqBracketed</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convSeq">Lean.Parser.Tactic.Conv.convSeq</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.conv">Lean.Parser.Tactic.Conv.conv</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.skip">Lean.Parser.Tactic.Conv.skip</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.lhs">Lean.Parser.Tactic.Conv.lhs</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.rhs">Lean.Parser.Tactic.Conv.rhs</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.whnf">Lean.Parser.Tactic.Conv.whnf</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.zeta">Lean.Parser.Tactic.Conv.zeta</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.reduce">Lean.Parser.Tactic.Conv.reduce</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.congr">Lean.Parser.Tactic.Conv.congr</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.arg">Lean.Parser.Tactic.Conv.arg</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.ext">Lean.Parser.Tactic.Conv.ext</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.change">Lean.Parser.Tactic.Conv.change</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.delta">Lean.Parser.Tactic.Conv.delta</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.unfold">Lean.Parser.Tactic.Conv.unfold</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.pattern">Lean.Parser.Tactic.Conv.pattern</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.rewrite">Lean.Parser.Tactic.Conv.rewrite</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.simp">Lean.Parser.Tactic.Conv.simp</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.simpMatch">Lean.Parser.Tactic.Conv.simpMatch</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.nestedTacticCore">Lean.Parser.Tactic.Conv.nestedTacticCore</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.nestedTactic">Lean.Parser.Tactic.Conv.nestedTactic</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.nestedConv">Lean.Parser.Tactic.Conv.nestedConv</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.paren">Lean.Parser.Tactic.Conv.paren</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convConvSeq">Lean.Parser.Tactic.Conv.convConvSeq</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.«conv·._»">Lean.Parser.Tactic.Conv.«conv·._»</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convRw__">Lean.Parser.Tactic.Conv.convRw__</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convErw_">Lean.Parser.Tactic.Conv.convErw_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convArgs">Lean.Parser.Tactic.Conv.convArgs</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convLeft">Lean.Parser.Tactic.Conv.convLeft</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convRight">Lean.Parser.Tactic.Conv.convRight</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convIntro__">Lean.Parser.Tactic.Conv.convIntro__</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.enterArg">Lean.Parser.Tactic.Conv.enterArg</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.«convEnter[__]»">Lean.Parser.Tactic.Conv.«convEnter[__]»</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convRfl">Lean.Parser.Tactic.Conv.convRfl</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convDone">Lean.Parser.Tactic.Conv.convDone</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convTrace_state">Lean.Parser.Tactic.Conv.convTrace_state</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convApply_">Lean.Parser.Tactic.Conv.convApply_</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.first">Lean.Parser.Tactic.Conv.first</a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.Conv.convRepeat_">Lean.Parser.Tactic.Conv.convRepeat_</a></div></nav><main>
<div class="decl" id="Lean.Parser.Tactic.Conv.conv.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L13-L18">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.conv.quot">Lean.Parser.Tactic.Conv.conv.quot</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Category.conv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L13-L18">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Category.conv">Lean.Parser.Category.conv</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Notation.html#Lean.Parser.Category">Lean.Parser.Category</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a></code> is the syntax category for a "conv tactic", where "conv" is short
for conversion. A conv tactic is a program which receives a target, printed as
<code>| a</code>, and is tasked with coming up with some term <code>b</code> and a proof of <code>a = b</code>.
It is mainly used for doing targeted term transformations, for example rewriting
only on the left side of an equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Category.conv">Lean.Parser.Category.conv</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Notation.html#Lean.Parser.Category.mk">{  }</a>   </span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convSeq1Indented"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L20-L20">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq1Indented">Lean.Parser.Tactic.Conv.convSeq1Indented</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convSeqBracketed"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L21-L21">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convSeqBracketed">Lean.Parser.Tactic.Conv.convSeqBracketed</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L24-L24">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq">Lean.Parser.Tactic.Conv.convSeq</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.conv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L26-L37">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.conv">Lean.Parser.Tactic.Conv.conv</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a> => ...</code> allows the user to perform targeted rewriting on a goal or hypothesis,
by focusing on particular subexpressions.</p><p>See <a href="https://leanprover.github.io/theorem_proving_in_lean4/conv.html">https://leanprover.github.io/theorem_proving_in_lean4/conv.html</a> for more details.</p><p>Basic forms:</p><ul>
<li><code><a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a> => cs</code> will rewrite the goal with conv tactics <code>cs</code>.</li>
<li><code><a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a> at h => cs</code> will rewrite hypothesis <code>h</code>.</li>
<li><code><a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a> in pat => cs</code> will rewrite the first subexpression matching <code>pat</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.skip"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L39-L40">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.skip">Lean.Parser.Tactic.Conv.skip</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.skip">skip</a></code> does nothing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.skip">Lean.Parser.Tactic.Conv.skip</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.skip</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotskip&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.lhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L42-L44">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.lhs">Lean.Parser.Tactic.Conv.lhs</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Traverses into the left subterm of a binary operator.
(In general, for an <code>n</code>-ary operator, it traverses into the second to last argument.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.lhs">Lean.Parser.Tactic.Conv.lhs</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.lhs</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotlhs&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.rhs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L46-L48">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.rhs">Lean.Parser.Tactic.Conv.rhs</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Traverses into the right subterm of a binary operator.
(In general, for an <code>n</code>-ary operator, it traverses into the last argument.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.rhs">Lean.Parser.Tactic.Conv.rhs</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.rhs</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotrhs&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.whnf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L50-L53">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.whnf">Lean.Parser.Tactic.Conv.whnf</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Reduces the target to Weak Head Normal Form. This reduces definitions
in "head position" until a constructor is exposed. For example, <code><a href=".././Init/Data/List/Basic.html#List.map">List.map</a> f [a, b, c]</code>
weak head normalizes to <code>f a :: <a href=".././Init/Data/List/Basic.html#List.map">List.map</a> f [b, c]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.whnf">Lean.Parser.Tactic.Conv.whnf</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.whnf</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotwhnf&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.zeta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L55-L56">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.zeta">Lean.Parser.Tactic.Conv.zeta</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Expand let-declarations and let-variables.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.zeta">Lean.Parser.Tactic.Conv.zeta</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.zeta</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotzeta&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.reduce"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L58-L59">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.reduce">Lean.Parser.Tactic.Conv.reduce</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Put term in normal form, this tactic is ment for debugging purposes only</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.reduce">Lean.Parser.Tactic.Conv.reduce</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.reduce</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotreduce&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.congr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L61-L64">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.congr">Lean.Parser.Tactic.Conv.congr</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Performs one step of "congruence", which takes a term and produces
subgoals for all the function arguments. For example, if the target is <code>f x y</code> then
<code><a href=".././Init/Prelude.html#congr">congr</a></code> produces two subgoals, one for <code>x</code> and one for <code>y</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.congr">Lean.Parser.Tactic.Conv.congr</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.congr</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotcongr&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.arg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L66-L71">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.arg">Lean.Parser.Tactic.Conv.arg</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><ul>
<li><code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.arg">arg</a> i</code> traverses into the <code>i</code>'th argument of the target. For example if the
target is <code>f a b c d</code> then <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.arg">arg</a> 1</code> traverses to <code>a</code> and <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.arg">arg</a> 3</code> traverses to <code>c</code>.</li>
<li><code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.arg">arg</a> @i</code> is the same as <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.arg">arg</a> i</code> but it counts all arguments instead of just the
explicit arguments.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.ext"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L73-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.ext">Lean.Parser.Tactic.Conv.ext</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.ext">ext</a> x</code> traverses into a binder (a <code>fun x => e</code> or <code>∀ x, e</code> expression)
to target <code>e</code>, introducing name <code>x</code> in the process.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.change"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L77-L79">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.change">Lean.Parser.Tactic.Conv.change</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.change">change</a> t'</code> replaces the target <code>t</code> with <code>t'</code>,
assuming <code>t</code> and <code>t'</code> are definitionally equal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.delta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L81-L85">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.delta">Lean.Parser.Tactic.Conv.delta</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.delta">delta</a> foo</code> unfolds all occurrences of <code>foo</code> in the target.
Like the <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.delta">delta</a></code> tactic, this ignores any definitional equations and uses
primitive delta-reduction instead, which may result in leaking implementation details.
Users should prefer <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.unfold">unfold</a></code> for unfolding definitions.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.unfold"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L87-L91">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.unfold">Lean.Parser.Tactic.Conv.unfold</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.unfold">unfold</a> foo</code> unfolds all occurrences of <code>foo</code> in the target.
Like the <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.unfold">unfold</a></code> tactic, this uses equational lemmas for the chosen definition
to rewrite the target. For recursive definitions,
only one layer of unfolding is performed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.pattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L93-L94">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.pattern">Lean.Parser.Tactic.Conv.pattern</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.pattern">pattern</a> pat</code> traverses to the first subterm of the target that matches <code>pat</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.rewrite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L96-L97">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.rewrite">Lean.Parser.Tactic.Conv.rewrite</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rw [thm]</code> rewrites the target using <code>thm</code>. See the <code>rw</code> tactic for more information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.simp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L99-L101">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.simp">Lean.Parser.Tactic.Conv.simp</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.simp">simp</a> [thm]</code> performs simplification using <code>thm</code> and marked <code>@[simp]</code> lemmas.
See the <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.simp">simp</a></code> tactic for more information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.simpMatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L103-L110">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.simpMatch">Lean.Parser.Tactic.Conv.simpMatch</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>simp_match</code> simplifies match expressions. For example,</p><pre><code>match [a, b] with
| [] => 0
| hd :: tl => hd
</code></pre><p>simplifies to <code>a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.simpMatch">Lean.Parser.Tactic.Conv.simpMatch</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.simpMatch</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotsimp_match&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.nestedTacticCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L113-L114">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTacticCore">Lean.Parser.Tactic.Conv.nestedTacticCore</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Execute the given tactic block without converting <code><a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a></code> goal into a regular goal</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.nestedTactic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L116-L117">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTactic">Lean.Parser.Tactic.Conv.nestedTactic</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Focus, convert the <code><a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a></code> goal <code>⊢ <a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.lhs">lhs</a></code> into a regular goal <code>⊢ <a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.lhs">lhs</a> = <a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.rhs">rhs</a></code>, and then execute the given tactic block.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.nestedConv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L119-L121">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.nestedConv">Lean.Parser.Tactic.Conv.nestedConv</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>{ convs }</code> runs the list of <code>convs</code> on the current target, and any subgoals that
remain are trivially closed by <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.skip">skip</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.nestedConv">Lean.Parser.Tactic.Conv.nestedConv</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.nestedConv</span> <span class="fn">1022</span> <a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convSeqBracketed">Lean.Parser.Tactic.Conv.convSeqBracketed</a></span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.paren"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L123-L125">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.paren">Lean.Parser.Tactic.Conv.paren</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>(convs)</code> runs the <code>convs</code> in sequence on the current list of targets.
This is pure grouping with no added effects.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convConvSeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L127-L129">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convConvSeq">Lean.Parser.Tactic.Conv.convConvSeq</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a> => cs</code> runs <code>cs</code> in sequence on the target <code>t</code>,
resulting in <code>t'</code>, which becomes the new target subgoal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.«conv·._»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L131-L132">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.«conv·._»">Lean.Parser.Tactic.Conv.«conv·._»</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>· <a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a></code> focuses on the main conv goal and tries to solve it using <code>s</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convRw__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L134-L136">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convRw__">Lean.Parser.Tactic.Conv.convRw__</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>rw [rules]</code> applies the given list of rewrite rules to the target.
See the <code>rw</code> tactic for more information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convErw_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L138-L141">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convErw_">Lean.Parser.Tactic.Conv.convErw_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>erw [rules]</code> is a shorthand for <code>rw (config := { transparency := .default }) [rules]</code>.
This does rewriting up to unfolding of regular definitions (by comparison to regular <code>rw</code>
which only unfolds <code>@[reducible]</code> definitions).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L143-L144">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convArgs">Lean.Parser.Tactic.Conv.convArgs</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>args</code> traverses into all arguments. Synonym for <code><a href=".././Init/Prelude.html#congr">congr</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convArgs">Lean.Parser.Tactic.Conv.convArgs</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.convArgs</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotargs&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L145-L146">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convLeft">Lean.Parser.Tactic.Conv.convLeft</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>left</code> traverses into the left argument. Synonym for <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.lhs">lhs</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convLeft">Lean.Parser.Tactic.Conv.convLeft</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.convLeft</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotleft&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L147-L148">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convRight">Lean.Parser.Tactic.Conv.convRight</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>right</code> traverses into the right argument. Synonym for <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.rhs">rhs</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convRight">Lean.Parser.Tactic.Conv.convRight</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.convRight</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotright&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convIntro__"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L149-L150">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convIntro__">Lean.Parser.Tactic.Conv.convIntro__</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>intro</code> traverses into binders. Synonym for <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.ext">ext</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.enterArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L152-L152">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.enterArg">Lean.Parser.Tactic.Conv.enterArg</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.«convEnter[__]»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L154-L161">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.«convEnter[__]»">Lean.Parser.Tactic.Conv.«convEnter[__]»</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>enter [arg, ...]</code> is a compact way to describe a path to a subterm.
It is a shorthand for other conv tactics as follows:</p><ul>
<li><code>enter [i]</code> is equivalent to <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.arg">arg</a> i</code>.</li>
<li><code>enter [@i]</code> is equivalent to <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.arg">arg</a> @i</code>.</li>
<li><code>enter [x]</code> (where <code>x</code> is an identifier) is equivalent to <code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.ext">ext</a> x</code>.
For example, given the target <code>f (g a (fun x => x b))</code>, <code>enter [1, 2, x, 1]</code>
will traverse to the subterm <code>b</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convRfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L168-L170">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convRfl">Lean.Parser.Tactic.Conv.convRfl</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Prelude.html#rfl">rfl</a></code> closes one conv goal "trivially", by using reflexivity
(that is, no rewriting).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convRfl">Lean.Parser.Tactic.Conv.convRfl</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.convRfl</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotrfl&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convDone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L172-L173">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convDone">Lean.Parser.Tactic.Conv.convDone</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>done</code> succeeds iff there are no goals remaining.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convDone">Lean.Parser.Tactic.Conv.convDone</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.convDone</span> <span class="fn">1024</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quotdone&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convTrace_state"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L175-L176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convTrace_state">Lean.Parser.Tactic.Conv.convTrace_state</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>trace_state</code> prints the current goal state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convTrace_state">Lean.Parser.Tactic.Conv.convTrace_state</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.Conv.convTrace_state</span> <span class="fn">1024</span>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quottrace_state&quot</span> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convApply_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L178-L182">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convApply_">Lean.Parser.Tactic.Conv.convApply_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>The <code>apply thm</code> conv tactic is the same as <code>apply thm</code> the tactic.
There are no restrictions on <code>thm</code>, but strange results may occur if <code>thm</code>
cannot be reasonably interpreted as proving one equality from a list of others.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.first"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L184-L185">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.first">Lean.Parser.Tactic.Conv.first</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code><a href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.first">first</a> | <a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a> | ...</code> runs each <code><a href=".././Init/Conv.html#Lean.Parser.Category.conv">conv</a></code> until one succeeds, or else fails.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.Conv.convRepeat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L187-L188">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Conv.html#Lean.Parser.Tactic.Conv.convRepeat_">Lean.Parser.Tactic.Conv.convRepeat_</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>repeat convs</code> runs the sequence <code>convs</code> repeatedly until it fails to apply.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div></main>
<nav class="nav"><iframe src=".././/navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>