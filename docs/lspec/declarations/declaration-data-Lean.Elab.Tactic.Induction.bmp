{"name":"Lean.Elab.Tactic.Induction","instances":[],"imports":["Init","Lean.Util.CollectFVars","Lean.Parser.Term","Lean.Meta.RecursorInfo","Lean.Meta.CollectMVars","Lean.Meta.Tactic.ElimInfo","Lean.Meta.Tactic.Induction","Lean.Meta.Tactic.Cases","Lean.Meta.GeneralizeVars","Lean.Elab.App","Lean.Elab.Tactic.ElabTerm","Lean.Elab.Tactic.Generalize"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L559-L585","name":"Lean.Elab.Tactic.evalCases","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalCases","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L537-L557","name":"Lean.Elab.Tactic.elabCasesTargets","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.elabCasesTargets","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L529-L535","name":"Lean.Elab.Tactic.evalInduction.checkTargets","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalInduction.checkTargets","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L500-L535","name":"Lean.Elab.Tactic.evalInduction","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalInduction","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L459-L465","name":"Lean.Elab.Tactic.getInductiveValFromMajor","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.getInductiveValFromMajor","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L328-L332","name":"Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L257-L327","name":"Lean.Elab.Tactic.ElimApp.evalAlts.go","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.evalAlts.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L247-L332","name":"Lean.Elab.Tactic.ElimApp.evalAlts","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.evalAlts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L234-L245","name":"Lean.Elab.Tactic.ElimApp.reorderAlts","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.reorderAlts","doc":"If `altsSyntax` is not empty we reorder `alts` using the order the alternatives have been provided\n  in `altsSyntax`. Motivations:\n\n  1- It improves the effectiveness of the `checkpoint` and `save` tactics. Consider the following example:\n  ```lean\n  example (h₁ : p ∨ q) (h₂ : p → x = 0) (h₃ : q → y = 0) : x * y = 0 := by\n    cases h₁ with\n    | inr h =>\n      sleep 5000 -- sleeps for 5 seconds\n      save\n      have : y = 0 := h₃ h\n      -- We can confortably work here\n    | inl h => stop ...\n  ```\n  If we do reorder, the `inl` alternative will be executed first. Moreover, as we type in the `inr` alternative,\n  type errors will \"swallow\" the `inl` alternative and affect the tactic state at `save` making it ineffective.\n\n  2- The errors are produced in the same order the appear in the code above. This is not super important when using IDEs.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L169-L176","name":"Lean.Elab.Tactic.ElimApp.setMotiveArg","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.setMotiveArg","doc":"Given a goal `... targets ... |- C[targets]` associated with `mvarId`, assign\n`motiveArg := fun targets => C[targets]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L115-L151","name":"Lean.Elab.Tactic.ElimApp.mkElimApp.loop","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.mkElimApp.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L114-L165","name":"Lean.Elab.Tactic.ElimApp.mkElimApp","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.mkElimApp","doc":"Construct the an eliminator/recursor application. `targets` contains the explicit and implicit targets for\nthe eliminator. For example, the indices of builtin recursors are considered implicit targets.\nRemark: the method `addImplicitTargets` may be used to compute the sequence of implicit and explicit targets\nfrom the explicit ones.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L103-L106","name":"Lean.Elab.Tactic.ElimApp.Result","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Result","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L88-L88","name":"Lean.Elab.Tactic.ElimApp.M","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L80-L86","name":"Lean.Elab.Tactic.ElimApp.State","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L76-L78","name":"Lean.Elab.Tactic.ElimApp.Context","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L54-L69","name":"Lean.Elab.Tactic.evalAlt","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Tactic/Induction.lean#L51-L52","name":"Lean.Elab.Tactic.isHoleRHS","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.isHoleRHS","doc":""}]}