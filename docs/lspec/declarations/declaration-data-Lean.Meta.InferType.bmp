{"name":"Lean.Meta.InferType","instances":[],"imports":["Init","Lean.Data.LBool","Lean.Meta.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L395-L396","name":"Lean.Meta.isTypeFormer","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormer","doc":"Return true iff `e : Sort _` or `e : (forall As, Sort _)`.\nRemark: it subsumes `isType`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L383-L389","name":"Lean.Meta.isTypeFormerType","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeFormerType","doc":"Return true iff `type` is `Sort _` or `As → Sort _`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L369-L378","name":"Lean.Meta.isType","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isType","doc":"Return `true` iff the type of `e` is a `Sort _`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L352-L364","name":"Lean.Meta.isTypeQuick","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isTypeQuick","doc":"`isTypeQuick e` is an \"approximate\" predicate which returns `LBool.true`\nif `e` is a type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L317-L321","name":"Lean.Meta.isProof","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProof","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L301-L313","name":"Lean.Meta.isProofQuick","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProofQuick","doc":"`isProofQuick e` is an \"approximate\" predicate which returns `LBool.true`\nif `e` is a proof. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L261-L270","name":"Lean.Meta.isProp","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isProp","doc":"`isProp whnf e` return `true` if `e` is a proposition.\n\n     If `e` contains metavariables, it may not be possible\n     to decide whether is a proposition or not. We return `false` in this\n     case. We considered using `LBool` and retuning `LBool.undef`, but\n     we have no applications for it. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L241-L253","name":"Lean.Meta.isPropQuick","docLink":"./Lean/Meta/InferType.html#Lean.Meta.isPropQuick","doc":"`isPropQuick e` is an \"approximate\" predicate which returns `LBool.true`\nif `e` is a proposition. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L184-L198","name":"Lean.Meta.inferTypeImp.infer","docLink":"./Lean/Meta/InferType.html#Lean.Meta.inferTypeImp.infer","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L183-L199","name":"Lean.Meta.inferTypeImp","docLink":"./Lean/Meta/InferType.html#Lean.Meta.inferTypeImp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L160-L161","name":"Lean.Meta.throwUnknownMVar","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwUnknownMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L125-L137","name":"Lean.Meta.getLevel","docLink":"./Lean/Meta/InferType.html#Lean.Meta.getLevel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L122-L123","name":"Lean.Meta.throwTypeExcepted","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwTypeExcepted","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L86-L87","name":"Lean.Meta.throwIncorrectNumberOfLevels","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwIncorrectNumberOfLevels","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L69-L70","name":"Lean.Meta.throwFunctionExpected","docLink":"./Lean/Meta/InferType.html#Lean.Meta.throwFunctionExpected","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L32-L65","name":"Lean.Expr.instantiateBetaRevRange.visit","docLink":"./Lean/Meta/InferType.html#Lean.Expr.instantiateBetaRevRange.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/InferType.lean#L25-L65","name":"Lean.Expr.instantiateBetaRevRange","docLink":"./Lean/Meta/InferType.html#Lean.Expr.instantiateBetaRevRange","doc":"Auxiliary function for instantiating the loose bound variables in `e` with `args[start:stop]`.\nThis function is similar to `instantiateRevRange`, but it applies beta-reduction when\nwe instantiate a bound variable with a lambda expression.\nExample: Given the term `#0 a`, and `start := 0, stop := 1, args := #[fun x => x]` the result is\n`a` instead of `(fun x => x) a`.\nThis reduction is useful when we are inferring the type of eliminator-like applications.\nFor example, given `(n m : Nat) (f : Nat → Nat) (h : m = n)`,\nthe type of `Eq.subst (motive := fun x => f m = f x) h rfl`\nis `motive n` which is `(fun (x : Nat) => f m = f x) n`\nThis function reduces the new application to `f m = f n`\n\nWe use it to implement `inferAppType`\n"}]}