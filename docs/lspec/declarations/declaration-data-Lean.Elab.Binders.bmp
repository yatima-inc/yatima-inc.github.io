{"name":"Lean.Elab.Binders","instances":[],"imports":["Init","Lean.Parser.Term","Lean.Elab.Quotation.Precheck","Lean.Elab.Term","Lean.Elab.BindersUtil","Lean.Elab.AuxDiscr"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L747-L748","name":"Lean.Elab.Term.elabLetTmpDecl","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetTmpDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L744-L745","name":"Lean.Elab.Term.elabLetDelayedDecl","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetDelayedDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L741-L742","name":"Lean.Elab.Term.elabLetFunDecl","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetFunDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L738-L739","name":"Lean.Elab.Term.elabLetDecl","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L704-L736","name":"Lean.Elab.Term.elabLetDeclCore","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetDeclCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L698-L702","name":"Lean.Elab.Term.expandLetEqnsDecl","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandLetEqnsDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L689-L696","name":"Lean.Elab.Term.mkLetIdDeclView","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.mkLetIdDeclView","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L683-L687","name":"Lean.Elab.Term.LetIdDeclView","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.LetIdDeclView","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L634-L681","name":"Lean.Elab.Term.elabLetDeclAux","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabLetDeclAux","doc":"If `useLetExpr` is true, then a kernel let-expression `let x : type := val; body` is created.\n   Otherwise, we create a term of the form `(fun (x : type) => body) val`\n\n   The default elaboration order is `binders`, `typeStx`, `valStx`, and `body`.\n   If `elabBodyFirst == true`, then we use the order `binders`, `typeStx`, `body`, and `valStx`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L614-L627","name":"Lean.Elab.Term.elabFun","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L603-L612","name":"Lean.Elab.Term.precheckFun","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.precheckFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L597-L600","name":"Lean.Elab.Term.expandExplicitFun","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandExplicitFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L584-L595","name":"Lean.Elab.Term.expandFun","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L569-L581","name":"Lean.Elab.Term.expandMatchAltsWhereDecls.loop","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandMatchAltsWhereDecls.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L566-L582","name":"Lean.Elab.Term.expandMatchAltsWhereDecls","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandMatchAltsWhereDecls","doc":"Similar to `expandMatchAltsIntoMatch`, but supports an optional `where` clause.\n\n  Expand `matchAltsWhereDecls` into `let rec` + `match`-expression.\n  Example\n  ```\n  | 0, true => ... f 0 ...\n  | i, _    => ... f i + g i ...\n  where\n    f x := g x + 1\n\n    g : Nat → Nat\n      | 0   => 1\n      | x+1 => f x\n  ```\n  expands into\n  ```\n  fux x_1 x_2 =>\n    let rec\n      f x := g x + 1,\n      g : Nat → Nat\n        | 0   => 1\n        | x+1 => f x\n    match x_1, x_2 with\n    | 0, true => ... f 0 ...\n    | i, _    => ... f i + g i ...\n  ```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L535-L536","name":"Lean.Elab.Term.expandMatchAltsIntoMatchTactic","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandMatchAltsIntoMatchTactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L532-L533","name":"Lean.Elab.Term.expandMatchAltsIntoMatch","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandMatchAltsIntoMatch","doc":"Expand `matchAlts` syntax into a full `match`-expression.\n  Example:\n  ```\n  | 0, true => alt_1\n  | i, _    => alt_2\n  ```\n  expands into (for tactic == false)\n  ```\n  fun x_1 x_2 =>\n  match @x_1, @x_2 with\n  | 0, true => alt_1\n  | i, _    => alt_2\n  ```\n  and (for tactic == true)\n  ```\n  intro x_1; intro x_2;\n  match @x_1, @x_2 with\n  | 0, true => alt_1\n  | i, _    => alt_2\n  ```\n\n  If `useExplicit = true`, we add a `@` before `fun` to disable implicit lambdas. We disable them when processing `let` and `let rec` declarations\n  to make sure the behavior is consistent with top-level declarations where we can write\n  ```\n  def f : {α : Type} → α → α\n    | _, a => a\n  ```\n  We use `useExplicit = false` when we are elaborating the `fun | ... => ... | ...` notation. See issue #1132.\n  If `@fun` is used with this notation, the we set `useExplicit = true`.\n  We also use `useExplicit = false` when processing `instance ... where` notation declarations. The motivation is to have compact declarations such as\n  ```\n  instance [Alternative m] : MonadLiftT Option m where\n  monadLift -- We don't want to provide the implicit arguments of `monadLift` here. One should use `monadLift := @fun ...` if they want to provide them.\n    | some a => pure a\n    | none => failure\n  ```\n\n  Remark: we add `@` at discriminants to make sure we don't consume implicit arguments, and to make the behavior consistent with `fun`.\n  Example:\n  ```\n  inductive T : Type 1 :=\n  | mkT : (forall {a : Type}, a -> a) -> T\n\n  def makeT (f : forall {a : Type}, a -> a) : T :=\n    mkT f\n\n  def makeT' : (forall {a : Type}, a -> a) -> T\n  | f => mkT f\n  ```\n  The two definitions should be elaborated without errors and be equivalent.\n "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L454-L458","name":"Lean.Elab.Term.expandWhereDeclsOpt","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandWhereDeclsOpt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L449-L452","name":"Lean.Elab.Term.expandWhereDecls","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandWhereDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L439-L447","name":"Lean.Elab.Term.elabFunBinders","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabFunBinders","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L429-L435","name":"Lean.Elab.Term.FunBinders.elabFunBindersAux","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.FunBinders.elabFunBindersAux","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L381-L385","name":"Lean.Elab.Term.FunBinders.State","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.FunBinders.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L328-L376","name":"Lean.Elab.Term.expandFunBinders.loop","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandFunBinders.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L327-L377","name":"Lean.Elab.Term.expandFunBinders","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandFunBinders","doc":"Auxiliary function for expanding `fun` notation binders. Recall that `fun` parser is defined as\n  ```\n  def funBinder : Parser := implicitBinder <|> instBinder <|> termParser maxPrec\n  leading_parser unicodeSymbol \"λ\" \"fun\" >> many1 funBinder >> \"=>\" >> termParser\n  ```\n  to allow notation such as `fun (a, b) => a + b`, where `(a, b)` should be treated as a pattern.\n  The result is a pair `(explicitBinders, newBody)`, where `explicitBinders` is syntax of the form\n  ```\n  `(` ident `:` term `)`\n  ```\n  which can be elaborated using `elabBinders`, and `newBody` is the updated `body` syntax.\n  We update the `body` syntax when expanding the pattern notation.\n  Example: `fun (a, b) => a + b` expands into `fun _a_1 => match _a_1 with | (a, b) => a + b`.\n  See local function `processAsPattern` at `expandFunBindersAux`.\n\n  The resulting `Bool` is true if a pattern was found. We use it \"mark\" a macro expansion. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L277-L282","name":"Lean.Elab.Term.elabDepArrow","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabDepArrow","doc":"The dependent arrow. `(x : α) → β` is equivalent to `∀ x : α, β`, but we usually\nreserve the latter for propositions. Also written as `Π x : α, β` (the \"Pi-type\")\nin the literature. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L264-L271","name":"Lean.Elab.Term.elabArrow","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabArrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L258-L262","name":"Lean.Elab.Term.precheckArrow","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.precheckArrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L249-L255","name":"Lean.Elab.Term.elabForall","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L243-L247","name":"Lean.Elab.Term.expandForall","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L237-L241","name":"Lean.Elab.Term.expandSimpleBinderWithType","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.expandSimpleBinderWithType","doc":"If `binder` is a `_` or an identifier, return a `bracketedBinder` using `type` otherwise throw an exception. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L233-L234","name":"Lean.Elab.Term.elabBinder","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabBinder","doc":"Same as `elabBinder` with a single binder."},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L229-L230","name":"Lean.Elab.Term.elabBinders","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabBinders","doc":"Elaborate the given binders (i.e., `Syntax` objects for `bracketedBinder`),\n  update the local context, set of local instances, reset instance chache (if needed), and then\n  execute `k` with the updated context.\n  The local context will only be included inside `k`.\n\n  For example, suppose you have binders `[(a : α), (b : β a)]`, then the elaborator will\n  create two new free variables `a` and `b`, push these to the context and pass to `k #[a,b]`.\n  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L213-L218","name":"Lean.Elab.Term.elabBindersEx","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.elabBindersEx","doc":"Like `elabBinders`, but also pass syntax node per binder.\n`elabBinders(Ex)` automatically adds binder info nodes for the produced fvars, but storing the syntax nodes\nmight be necessary when later adding the same binders back to the local context so that info nodes can\nmanually be added for the new fvars; see `MutualDef` for an example. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L168-L168","name":"Lean.Elab.Term.checkBinderAnnotations","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.checkBinderAnnotations","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L160-L161","name":"Lean.Elab.Term.addLocalVarInfo","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.addLocalVarInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L79-L91","name":"Lean.Elab.Term.declareTacticSyntax","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.declareTacticSyntax","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L62-L77","name":"Lean.Elab.Term.quoteAutoTactic","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.quoteAutoTactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Binders.lean#L43-L60","name":"Lean.Elab.Term.BinderView","docLink":"./Lean/Elab/Binders.html#Lean.Elab.Term.BinderView","doc":"Auxiliary datatype for elaborating binders. "}]}