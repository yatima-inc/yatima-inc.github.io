{"name":"Init.Tactics","instances":[],"imports":["Init.Notation"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L588-L588","name":"«term__[_]'_»","docLink":"./Init/Tactics.html#«term__[_]'_»","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L585-L586","name":"getElem'","docLink":"./Init/Tactics.html#getElem'","doc":"Helper declaration for the unexpander "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L582-L582","name":"«term__[_]»","docLink":"./Init/Tactics.html#«term__[_]»","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L567-L572","name":"tacticGet_elem_tactic","docLink":"./Init/Tactics.html#tacticGet_elem_tactic","doc":"`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L556-L562","name":"tacticGet_elem_tactic_trivial","docLink":"./Init/Tactics.html#tacticGet_elem_tactic_trivial","doc":"`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith`\n(for doing linear arithmetic in the index). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L551-L554","name":"«term‹_›»","docLink":"./Init/Tactics.html#«term‹_›»","doc":"`‹t›` resolves to an (arbitrary) hypothesis of type `t`. It is useful for referring to hypotheses without accessible names.\n`t` may contain holes that are solved by unification with the expected type; in particular, `‹_›` is a shortcut for `by assumption`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L508-L545","name":"Lean.Parser.Attr.simp","docLink":"./Init/Tactics.html#Lean.Parser.Attr.simp","doc":"Theorems tagged with the `simp` attribute are by the simplifier (i.e., the `simp` tactic, and its variants) to simplify\nexpressions occurring in your goals.\nWe call theorems tagged with the `simp` attribute \"simp theorems\" or \"simp lemmas\".\nLean maintains a database/index containing all active simp theorems.\nHere is an example of a simp theorem.\n```lean\n@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl\n```\nThis simp theorem instructs the simplifier to replace instances of the term `a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)`\n(e.g., `Not (x + 0 = y)`).\nThe simplifier applies simp theorems in one direction only: if `A = B` is a simp theorem, then `simp`\nreplaces `A`s with `B`s, but it doesn't replace `B`s with `A`s. Hence a simp theorem should have the\nproperty that its right-hand side is \"simpler\" than its left-hand side.\nIn particular, `=` and `↔` should not be viewed as symmetric operators in this situation.\nThe following would be a terrible simp theorem (if it were even allowed):\n```lean\n@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...\n```\nReplacing 1 with a * a⁻¹ is not a sensible default direction to travel. Even worse would be a theorem\nthat causes expressions to grow without bound, causing simp to loop forever.\n\nBy default the simplifier applies `simp` theorems to an expression `e` after its sub-expressions have been simplified.\nWe say it performs a bottom-up simplification. You can instruct the simplifier to apply a theorem before its sub-expressions\nhave been simplified by using the modifier `↓`. Here is an example\n```lean\n@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=\n```\n\nWhen multiple simp theorems are applicable, the simplifier uses the one with highest priority. If there are several with\nthe same priority, it is uses the \"most recent one\". Example:\n```lean\n@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl\n@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True := propext <| Iff.intro (fun _ => trivial) (fun _ => Or.inr trivial)\n@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by cases d  <;> rfl\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L496-L503","name":"Lean.Parser.Tactic.congr","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.congr","doc":"Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications. This is useful when `congr` is too aggressive\nin breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`, `congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L492-L494","name":"Lean.Parser.Tactic.«tacticExists_,,»","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tacticExists_,,»","doc":"`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`. It is useful for existential goals. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L489-L490","name":"Lean.Parser.Tactic.sleep","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.sleep","doc":"The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing. It is used for debugging purposes only. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L479-L487","name":"Lean.Parser.Tactic.save","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.save","doc":"`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L468-L477","name":"Lean.Parser.Tactic.checkpoint","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.checkpoint","doc":"`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L465-L466","name":"Lean.Parser.Tactic.fail","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.fail","doc":"`fail msg` is a tactic that always fail and produces an error using the given message. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L452-L463","name":"Lean.Parser.Tactic.tacticUnhygienic_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_","doc":"`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L437-L443","name":"Lean.Parser.Tactic.specialize","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.specialize","doc":"The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or non-dependent implications,\nare instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L433-L435","name":"Lean.Parser.Tactic.tacticStop_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticStop_","doc":"`stop` is a helper tactic for \"discarding\" the rest of a proof. It is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L422-L431","name":"Lean.Parser.Tactic.dbgTrace","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.dbgTrace","doc":"`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L416-L420","name":"Lean.Parser.Tactic.split","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.split","doc":"The `split` tactic is useful for breaking nested if-then-else and match expressions in cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L407-L414","name":"Lean.Parser.Tactic.tacticTrivial","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial","doc":"`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...) to close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L399-L403","name":"Lean.Parser.Tactic.tacticRepeat_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_","doc":"`repeat tac` applies `tac` to main goal. If the application succeeds,\nthe tactic is applied recursively to the generated subgoals until it eventually fails.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L396-L397","name":"Lean.Parser.Tactic.renameI","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.renameI","doc":"`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L383-L394","name":"Lean.Parser.Tactic.cases","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.cases","doc":"Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`, uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L382-L382","name":"Lean.Parser.Tactic.casesTarget","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.casesTarget","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L377-L380","name":"Lean.Parser.Tactic.generalize","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.generalize","doc":"`generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal with a fresh hypothesis `x`s.\nIf `h` is given, `h : e = x` is introduced as well. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L376-L376","name":"Lean.Parser.Tactic.generalizeArg","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.generalizeArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L360-L374","name":"Lean.Parser.Tactic.induction","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.induction","doc":"Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂` uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L359-L359","name":"Lean.Parser.Tactic.inductionAlts","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.inductionAlts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L358-L358","name":"Lean.Parser.Tactic.inductionAlt","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.inductionAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L357-L357","name":"Lean.Parser.Tactic.inductionAltLHS","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.inductionAltLHS","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L354-L355","name":"Lean.Parser.Tactic.tacticLet'_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticLet'_","doc":"Similar to `let`, but using `refine'` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L352-L353","name":"Lean.Parser.Tactic.«tacticHave'_:=_»","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tacticHave'_:=_»","doc":"Similar to `have`, but using `refine'` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L350-L351","name":"Lean.Parser.Tactic.tacticHave'_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticHave'_","doc":"Similar to `have`, but using `refine'` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L348-L349","name":"Lean.Parser.Tactic.tacticRefine_lift'_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_","doc":"Similar to `refine_lift`, but using `refine'` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L342-L344","name":"Lean.Parser.Tactic.letrec","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.letrec","doc":"`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L337-L341","name":"Lean.Parser.Tactic.tacticShow_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticShow_","doc":"`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L330-L336","name":"Lean.Parser.Tactic.tacticLet_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticLet_","doc":"`let h : t := e` adds the hypothesis `h : t := e` to the current goal if `e` a term of type `t`.\nIf `t` is omitted, it will be inferred.\nThe variant `let pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `let ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L322-L329","name":"Lean.Parser.Tactic.tacticSuffices_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_","doc":"Given a main goal `ctx |- t`, `suffices h : t' from e` replaces the main goal with `ctx |- t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L318-L321","name":"Lean.Parser.Tactic.«tacticHave_:=_»","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tacticHave_:=_»","doc":"`have h := e` adds the hypothesis `h : t` if `e : t`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L310-L316","name":"Lean.Parser.Tactic.tacticHave_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticHave_","doc":"`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L306-L308","name":"Lean.Parser.Tactic.tacticRefine_lift_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_","doc":"Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L300-L304","name":"Lean.Parser.Tactic.unfold","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.unfold","doc":"`unfold id,+` unfolds definition `id`. For non-recursive definitions, this tactic is identical to `delta`.\nFor recursive definitions, it hides the encoding tricks used by the Lean frontend to convince the\nkernel that the definition terminates. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L296-L299","name":"Lean.Parser.Tactic.delta","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.delta","doc":"`delta id` delta-expands the definition `id`.\nThis is a low-level tactic, it will expose how recursive definitions have been compiled by Lean. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L290-L294","name":"Lean.Parser.Tactic.dsimp","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.dsimp","doc":"The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only applies theorems that hold by\nreflexivity. Thus, the result is guaranteed to be definitionally equal to the input.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L283-L288","name":"Lean.Parser.Tactic.simpAll","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpAll","doc":"`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target are simplified\nmultiple times until no simplication is applicable.\nOnly non-dependent propositional hypotheses are considered.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L271-L282","name":"Lean.Parser.Tactic.simp","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simp","doc":"The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L270-L270","name":"Lean.Parser.Tactic.simpStar","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpStar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L269-L269","name":"Lean.Parser.Tactic.simpErase","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpErase","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L268-L268","name":"Lean.Parser.Tactic.simpLemma","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpLemma","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L267-L267","name":"Lean.Parser.Tactic.simpPost","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpPost","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L266-L266","name":"Lean.Parser.Tactic.simpPre","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.simpPre","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L264-L264","name":"Lean.Parser.Tactic.discharger","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.discharger","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L258-L262","name":"Lean.Parser.Tactic.injections","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.injections","doc":"`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L247-L256","name":"Lean.Parser.Tactic.injection","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.injection","doc":"The `injection` tactic is based on the fact that constructors of inductive data types are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂`\nplaced in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂`\nshould be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L237-L240","name":"Lean.Parser.Tactic.rwSeq","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rwSeq","doc":"`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L228-L235","name":"Lean.Parser.Tactic.rewriteSeq","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq","doc":"`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used. This provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-` can also be used, to signify the target of the goal.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L226-L226","name":"Lean.Parser.Tactic.rwRuleSeq","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L225-L225","name":"Lean.Parser.Tactic.rwRule","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rwRule","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L218-L223","name":"Lean.Parser.Tactic.changeWith","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.changeWith","doc":"* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L210-L216","name":"Lean.Parser.Tactic.change","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.change","doc":"* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L208-L208","name":"Lean.Parser.Tactic.location","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.location","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L207-L207","name":"Lean.Parser.Tactic.locationHyp","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.locationHyp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L206-L206","name":"Lean.Parser.Tactic.locationWildcard","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.locationWildcard","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L203-L204","name":"Lean.Parser.Tactic.config","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.config","doc":"Optional configuration option for tactics "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L200-L201","name":"Lean.Parser.Tactic.tacticInfer_instance","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance","doc":"`infer_instance` is an abbreviation for `exact inferInstance` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L198-L199","name":"Lean.Parser.Tactic.tacticSorry","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticSorry","doc":"The `sorry` tactic is a shorthand for `exact sorry`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L196-L197","name":"Lean.Parser.Tactic.tacticAdmit","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit","doc":"`admit` is a shorthand for `exact sorry`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L186-L194","name":"Lean.Parser.Tactic.acRfl","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.acRfl","doc":"`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : IsAssociative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : IsCommutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L181-L184","name":"Lean.Parser.Tactic.tacticRfl'","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'","doc":"`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L174-L179","name":"Lean.Parser.Tactic.tacticRfl","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticRfl","doc":"`rfl` tries to close the current goal using reflexivity.\nThis is supposed to be an extensible tactic and users can add their own support\nfor new reflexive relations.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L171-L172","name":"Lean.Parser.Tactic.refl","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.refl","doc":"`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L163-L164","name":"Lean.Parser.Tactic.«tactic_<;>_»","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tactic_<;>_»","doc":"`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal, concatenating all goals produced by `tac'`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L161-L162","name":"Lean.Parser.Tactic.tacticTry_","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.tacticTry_","doc":"`try tac` runs `tac` and succeeds even if `tac` failed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L158-L160","name":"Lean.Parser.Tactic.rotateRight","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rotateRight","doc":"Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L154-L157","name":"Lean.Parser.Tactic.rotateLeft","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rotateLeft","doc":"`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L152-L153","name":"Lean.Parser.Tactic.first","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.first","doc":"`first | tac | ...` runs each `tac` until one succeeds, or else fails. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L149-L151","name":"Lean.Parser.Tactic.withUnfoldingAll","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll","doc":"`with_unfolding_all tacs` excutes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L146-L148","name":"Lean.Parser.Tactic.withReducibleAndInstances","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances","doc":"`with_reducible_and_instances tacs` excutes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L143-L145","name":"Lean.Parser.Tactic.withReducible","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withReducible","doc":"`with_reducible tacs` excutes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L139-L142","name":"Lean.Parser.Tactic.paren","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.paren","doc":"`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L137-L138","name":"Lean.Parser.Tactic.failIfSuccess","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess","doc":"`fail_if_success t` fails if the tactic `t` succeeds. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L135-L136","name":"Lean.Parser.Tactic.traceMessage","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.traceMessage","doc":"`trace msg` displays `msg` in the info view. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L133-L134","name":"Lean.Parser.Tactic.traceState","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.traceState","doc":"`trace_state` displays the current state in the info view. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L131-L132","name":"Lean.Parser.Tactic.done","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.done","doc":"`done` succeeds iff there are no remaining goals. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L129-L130","name":"Lean.Parser.Tactic.skip","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.skip","doc":"`skip` does nothing. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L125-L128","name":"Lean.Parser.Tactic.focus","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.focus","doc":"`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L123-L124","name":"Lean.Parser.Tactic.anyGoals","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.anyGoals","doc":"`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at least one application succeeds.  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L121-L122","name":"Lean.Parser.Tactic.allGoals","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.allGoals","doc":"`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L116-L119","name":"Lean.Parser.Tactic.«tacticNext_=>_»","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.«tacticNext_=>_»","doc":"`next => tac` focuses on the next goal solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with inaccessible names to the given names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L109-L114","name":"Lean.Parser.Tactic.case'","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.case'","doc":"`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal has been solved after applying `tac`, nor\nadmits the goal if `tac` failed. Recall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L105-L108","name":"Lean.Parser.Tactic.case","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.case","doc":"`case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`, or else fails.\n`case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with inaccessible names to the given names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L103-L104","name":"Lean.Parser.Tactic.constructor","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.constructor","doc":"If the main goal's target type is an inductive type, `constructor` solves it with the first matching constructor, or else fails. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L101-L102","name":"Lean.Parser.Tactic.refine'","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.refine'","doc":"`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`) and implicit parameters are also converted into new goals. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L96-L100","name":"Lean.Parser.Tactic.refine","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.refine","doc":"`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`) holes in `e` that are not solved\nby unification with the main goal's target type are converted into new goals, using the hole's name, if any, as the goal case name.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L92-L95","name":"Lean.Parser.Tactic.exact","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.exact","doc":"`exact e` closes the main goal if its target type matches that of `e`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L83-L91","name":"Lean.Parser.Tactic.apply","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.apply","doc":"`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L59-L82","name":"Lean.Parser.Tactic.contradiction","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.contradiction","doc":"`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : ¬ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x ≠ x) : p := by contradiction\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L55-L58","name":"Lean.Parser.Tactic.assumption","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.assumption","doc":"`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L50-L53","name":"Lean.Parser.Tactic.substVars","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.substVars","doc":"Apply `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L46-L49","name":"Lean.Parser.Tactic.subst","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.subst","doc":"`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis of type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L44-L45","name":"Lean.Parser.Tactic.clear","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.clear","doc":"`clear x...` removes the given hypotheses, or fails if there are remaining references to a hypothesis. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L42-L43","name":"Lean.Parser.Tactic.revert","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.revert","doc":"`revert x...` is the inverse of `intro x...`: it moves the given hypotheses into the main goal's target type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L38-L41","name":"Lean.Parser.Tactic.rename","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.rename","doc":"`rename t => x` renames the most recent hypothesis whose type matches `t` (which may contain placeholders) to `x`,\nor fails if no such hypothesis could be found. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L36-L37","name":"Lean.Parser.Tactic.intros","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.intros","doc":"`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous) hypotheses until goal is not of a function type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L17-L35","name":"Lean.Parser.Tactic.intro","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.intro","doc":"Introduce one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,\n  or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L14-L15","name":"Lean.Parser.Tactic.withAnnotateState","docLink":"./Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState","doc":"`with_annotate_state stx t` annotates the lexical range of `stx : Syntax` with the initial and final state of running tactic `t`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Tactics.lean#L11-L11","name":"Lean.binderIdent","docLink":"./Init/Tactics.html#Lean.binderIdent","doc":""}]}