{"name":"Lean.Meta.ExprDefEq","instances":[{"typeNames":["Lean.Expr","Lean.Expr","Lean.Meta.CheckAssignment.CheckAssignmentM"],"name":"Lean.Meta.CheckAssignment.instMonadCacheExprCheckAssignmentM","className":"Lean.MonadCache"}],"imports":["Init","Lean.ProjFns","Lean.Structure","Lean.Meta.WHNF","Lean.Meta.InferType","Lean.Meta.FunInfo","Lean.Meta.Check","Lean.Meta.Offset","Lean.Meta.ForEachExpr","Lean.Meta.UnificationHint"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L1733-L1769","name":"Lean.Meta.isExprDefEqAuxImpl","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.isExprDefEqAuxImpl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L1605-L1610","name":"Lean.Meta.whenUndefDo","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.whenUndefDo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L872-L889","name":"Lean.Meta.checkAssignment","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.checkAssignment","doc":"Auxiliary function for handling constraints of the form `?m a₁ ... aₙ =?= v`.\nIt will check whether we can perform the assignment\n```\n?m := fun fvars => v\n```\nThe result is `none` if the assignment can't be performed.\nThe result is `some newV` where `newV` is a possibly updated `v`. This method may need\nto unfold let-declarations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L827-L858","name":"Lean.Meta.CheckAssignmentQuick.check.visit","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignmentQuick.check.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L824-L859","name":"Lean.Meta.CheckAssignmentQuick.check","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignmentQuick.check","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L792-L806","name":"Lean.Meta.CheckAssignment.check","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.check","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L762-L790","name":"Lean.Meta.CheckAssignment.checkApp","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkApp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L759-L760","name":"Lean.Meta.CheckAssignment.checkAssignmentAux","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkAssignmentAux","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L748-L756","name":"Lean.Meta.CheckAssignment.assignToConstFun","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.assignToConstFun","doc":"Auxiliary function used to \"fix\" subterms of the form `?m x_1 ... x_n` where `x_i`s are free variables,\nand one of them is out-of-scope.\nSee `Expr.app` case at `check`.\nIf `ctxApprox` is true, then we solve this case by creating a fresh metavariable ?n with the correct scope,\nan assigning `?m := fun _ ... _ => ?n` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L683-L740","name":"Lean.Meta.CheckAssignment.checkMVar","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L668-L681","name":"Lean.Meta.CheckAssignment.checkFVar","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkFVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L657-L664","name":"Lean.Meta.CheckAssignment.run","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.run","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L646-L648","name":"Lean.Meta.CheckAssignment.instMonadCacheExprCheckAssignmentM","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.instMonadCacheExprCheckAssignmentM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L637-L638","name":"Lean.Meta.CheckAssignment.throwOutOfScopeFVar","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.throwOutOfScopeFVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L634-L635","name":"Lean.Meta.CheckAssignment.throwCheckAssignmentFailure","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.throwCheckAssignmentFailure","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L632-L632","name":"Lean.Meta.CheckAssignment.CheckAssignmentM","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.CheckAssignmentM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L625-L630","name":"Lean.Meta.CheckAssignment.Context","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L622-L623","name":"Lean.Meta.CheckAssignment.State","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L620-L620","name":"Lean.Meta.CheckAssignment.outOfScopeExceptionId","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.outOfScopeExceptionId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L619-L619","name":"Lean.Meta.CheckAssignment.checkAssignmentExceptionId","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.CheckAssignment.checkAssignmentExceptionId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L614-L615","name":"Lean.Meta.mkAuxMVar","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.mkAuxMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L276-L289","name":"Lean.Meta.isDefEqBindingDomain.loop","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqBindingDomain.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L275-L290","name":"Lean.Meta.isDefEqBindingDomain","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqBindingDomain","doc":"Check whether the types of the free variables at `fvars` are\n  definitionally equal to the types at `ds₂`.\n\n  Pre: `fvars.size == ds₂.size`\n\n  This method also updates the set of local instances, and invokes\n  the continuation `k` with the updated set.\n\n  We can't use `withNewLocalInstances` because the `isDeq fvarType d₂`\n  may use local instances. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L145-L178","name":"Lean.Meta.DefEqArgsFirstPassResult","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.DefEqArgsFirstPassResult","doc":"Result type for `isDefEqArgsFirstPass`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L125-L134","name":"Lean.Meta.isEtaUnassignedMVar","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.isEtaUnassignedMVar","doc":"Return `true` if `e` is of the form `fun (x_1 ... x_n) => ?m x_1 ... x_n)`, and `?m` is unassigned.\nRemark: `n` may be 0. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L113-L120","name":"Lean.Meta.isDefEqStringLit","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqStringLit","doc":"Support for constraints of the form `(\"...\" =?= String.mk cs)` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L99-L110","name":"Lean.Meta.isDefEqNat","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqNat","doc":"Support for reducing Nat basic operations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/ExprDefEq.lean#L88-L96","name":"Lean.Meta.isDefEqNative","docLink":"./Lean/Meta/ExprDefEq.html#Lean.Meta.isDefEqNative","doc":"Support for `Lean.reduceBool` and `Lean.reduceNat` "}]}