{"name":"Lean.Meta.Transform","instances":[],"imports":["Init","Lean.Meta.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L148-L149","name":"Lean.Meta.erasePatternRefAnnotations","docLink":"./Lean/Meta/Transform.html#Lean.Meta.erasePatternRefAnnotations","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L145-L146","name":"Lean.Meta.eraseInaccessibleAnnotations","docLink":"./Lean/Meta/Transform.html#Lean.Meta.eraseInaccessibleAnnotations","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L126-L143","name":"Lean.Meta.unfoldDeclsFrom","docLink":"./Lean/Meta/Transform.html#Lean.Meta.unfoldDeclsFrom","doc":"Unfold definitions and theorems in `e` that are not in the current environment, but are in `biggerEnv`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L111-L123","name":"Lean.Meta.zetaReduce","docLink":"./Lean/Meta/Transform.html#Lean.Meta.zetaReduce","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L90-L95","name":"Lean.Meta.transform.visit.visitLet","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitLet","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L84-L89","name":"Lean.Meta.transform.visit.visitForall","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L78-L83","name":"Lean.Meta.transform.visit.visitLambda","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitLambda","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L74-L77","name":"Lean.Meta.transform.visit.visitPost","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit.visitPost","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L72-L108","name":"Lean.Meta.transform.visit","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L64-L109","name":"Lean.Meta.transform","docLink":"./Lean/Meta/Transform.html#Lean.Meta.transform","doc":"Similar to `Core.transform`, but terms provided to `pre` and `post` do not contain loose bound variables.\nSo, it is safe to use any `MetaM` method at `pre` and `post`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L54-L55","name":"Lean.Core.betaReduce","docLink":"./Lean/Meta/Transform.html#Lean.Core.betaReduce","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L38-L41","name":"Lean.Core.transform.visit.visitPost","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform.visit.visitPost","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L36-L51","name":"Lean.Core.transform.visit","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L29-L52","name":"Lean.Core.transform","docLink":"./Lean/Meta/Transform.html#Lean.Core.transform","doc":"Tranform the expression `input` using `pre` and `post`.\n  - `pre s` is invoked before visiting the children of subterm 's'. If the result is `TransformStep.visit sNew`, then\n     `sNew` is traversed by transform. If the result is `TransformStep.done sNew`, then `s` is just replaced with `sNew`.\n     In both cases, `sNew` must be definitionally equal to `s`\n  - `post s` is invoked after visiting the children of subterm `s`.\n\n  The term `s` in both `pre s` and `post s` may contain loose bound variables. So, this method is not appropriate for\n  if one needs to apply operations (e.g., `whnf`, `inferType`) that do not handle loose bound variables.\n  Consider using `Meta.transform` to avoid loose bound variables.\n\n  This method is useful for applying transformations such as beta-reduction and delta-reduction.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Meta/Transform.lean#L10-L12","name":"Lean.TransformStep","docLink":"./Lean/Meta/Transform.html#Lean.TransformStep","doc":""}]}