{"name":"Init.Conv","instances":[],"imports":["Init.NotationExtra"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L187-L188","name":"Lean.Parser.Tactic.Conv.convRepeat_","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRepeat_","doc":"`repeat convs` runs the sequence `convs` repeatedly until it fails to apply. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L184-L185","name":"Lean.Parser.Tactic.Conv.first","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.first","doc":"`first | conv | ...` runs each `conv` until one succeeds, or else fails. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L178-L182","name":"Lean.Parser.Tactic.Conv.convApply_","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convApply_","doc":"The `apply thm` conv tactic is the same as `apply thm` the tactic.\nThere are no restrictions on `thm`, but strange results may occur if `thm`\ncannot be reasonably interpreted as proving one equality from a list of others. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L175-L176","name":"Lean.Parser.Tactic.Conv.convTrace_state","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convTrace_state","doc":"`trace_state` prints the current goal state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L172-L173","name":"Lean.Parser.Tactic.Conv.convDone","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convDone","doc":"`done` succeeds iff there are no goals remaining. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L168-L170","name":"Lean.Parser.Tactic.Conv.convRfl","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRfl","doc":"`rfl` closes one conv goal \"trivially\", by using reflexivity\n(that is, no rewriting). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L154-L161","name":"Lean.Parser.Tactic.Conv.«convEnter[__]»","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.«convEnter[__]»","doc":"`enter [arg, ...]` is a compact way to describe a path to a subterm.\nIt is a shorthand for other conv tactics as follows:\n* `enter [i]` is equivalent to `arg i`.\n* `enter [@i]` is equivalent to `arg @i`.\n* `enter [x]` (where `x` is an identifier) is equivalent to `ext x`.\nFor example, given the target `f (g a (fun x => x b))`, `enter [1, 2, x, 1]`\nwill traverse to the subterm `b`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L152-L152","name":"Lean.Parser.Tactic.Conv.enterArg","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.enterArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L149-L150","name":"Lean.Parser.Tactic.Conv.convIntro__","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convIntro__","doc":"`intro` traverses into binders. Synonym for `ext`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L147-L148","name":"Lean.Parser.Tactic.Conv.convRight","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRight","doc":"`right` traverses into the right argument. Synonym for `rhs`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L145-L146","name":"Lean.Parser.Tactic.Conv.convLeft","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convLeft","doc":"`left` traverses into the left argument. Synonym for `lhs`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L143-L144","name":"Lean.Parser.Tactic.Conv.convArgs","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convArgs","doc":"`args` traverses into all arguments. Synonym for `congr`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L138-L141","name":"Lean.Parser.Tactic.Conv.convErw_","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convErw_","doc":"`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L134-L136","name":"Lean.Parser.Tactic.Conv.convRw__","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convRw__","doc":"`rw [rules]` applies the given list of rewrite rules to the target.\nSee the `rw` tactic for more information. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L131-L132","name":"Lean.Parser.Tactic.Conv.«conv·._»","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.«conv·._»","doc":"`· conv` focuses on the main conv goal and tries to solve it using `s` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L127-L129","name":"Lean.Parser.Tactic.Conv.convConvSeq","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convConvSeq","doc":"`conv => cs` runs `cs` in sequence on the target `t`,\nresulting in `t'`, which becomes the new target subgoal. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L123-L125","name":"Lean.Parser.Tactic.Conv.paren","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.paren","doc":"`(convs)` runs the `convs` in sequence on the current list of targets.\nThis is pure grouping with no added effects. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L119-L121","name":"Lean.Parser.Tactic.Conv.nestedConv","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedConv","doc":"`{ convs }` runs the list of `convs` on the current target, and any subgoals that\nremain are trivially closed by `skip`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L116-L117","name":"Lean.Parser.Tactic.Conv.nestedTactic","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTactic","doc":"Focus, convert the `conv` goal `⊢ lhs` into a regular goal `⊢ lhs = rhs`, and then execute the given tactic block. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L113-L114","name":"Lean.Parser.Tactic.Conv.nestedTacticCore","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.nestedTacticCore","doc":"Execute the given tactic block without converting `conv` goal into a regular goal "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L103-L110","name":"Lean.Parser.Tactic.Conv.simpMatch","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.simpMatch","doc":"`simp_match` simplifies match expressions. For example,\n```\nmatch [a, b] with\n| [] => 0\n| hd :: tl => hd\n```\nsimplifies to `a`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L99-L101","name":"Lean.Parser.Tactic.Conv.simp","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.simp","doc":"`simp [thm]` performs simplification using `thm` and marked `@[simp]` lemmas.\nSee the `simp` tactic for more information. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L96-L97","name":"Lean.Parser.Tactic.Conv.rewrite","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.rewrite","doc":"`rw [thm]` rewrites the target using `thm`. See the `rw` tactic for more information. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L93-L94","name":"Lean.Parser.Tactic.Conv.pattern","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.pattern","doc":"`pattern pat` traverses to the first subterm of the target that matches `pat`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L87-L91","name":"Lean.Parser.Tactic.Conv.unfold","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.unfold","doc":"`unfold foo` unfolds all occurrences of `foo` in the target.\nLike the `unfold` tactic, this uses equational lemmas for the chosen definition\nto rewrite the target. For recursive definitions,\nonly one layer of unfolding is performed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L81-L85","name":"Lean.Parser.Tactic.Conv.delta","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.delta","doc":"`delta foo` unfolds all occurrences of `foo` in the target.\nLike the `delta` tactic, this ignores any definitional equations and uses\nprimitive delta-reduction instead, which may result in leaking implementation details.\nUsers should prefer `unfold` for unfolding definitions. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L77-L79","name":"Lean.Parser.Tactic.Conv.change","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.change","doc":"`change t'` replaces the target `t` with `t'`,\nassuming `t` and `t'` are definitionally equal. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L73-L75","name":"Lean.Parser.Tactic.Conv.ext","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.ext","doc":"`ext x` traverses into a binder (a `fun x => e` or `∀ x, e` expression)\nto target `e`, introducing name `x` in the process. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L66-L71","name":"Lean.Parser.Tactic.Conv.arg","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.arg","doc":"* `arg i` traverses into the `i`'th argument of the target. For example if the\n  target is `f a b c d` then `arg 1` traverses to `a` and `arg 3` traverses to `c`.\n* `arg @i` is the same as `arg i` but it counts all arguments instead of just the\n  explicit arguments. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L61-L64","name":"Lean.Parser.Tactic.Conv.congr","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.congr","doc":"Performs one step of \"congruence\", which takes a term and produces\nsubgoals for all the function arguments. For example, if the target is `f x y` then\n`congr` produces two subgoals, one for `x` and one for `y`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L58-L59","name":"Lean.Parser.Tactic.Conv.reduce","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.reduce","doc":"Put term in normal form, this tactic is ment for debugging purposes only "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L55-L56","name":"Lean.Parser.Tactic.Conv.zeta","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.zeta","doc":"Expand let-declarations and let-variables. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L50-L53","name":"Lean.Parser.Tactic.Conv.whnf","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.whnf","doc":"Reduces the target to Weak Head Normal Form. This reduces definitions\nin \"head position\" until a constructor is exposed. For example, `List.map f [a, b, c]`\nweak head normalizes to `f a :: List.map f [b, c]`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L46-L48","name":"Lean.Parser.Tactic.Conv.rhs","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.rhs","doc":"Traverses into the right subterm of a binary operator.\n(In general, for an `n`-ary operator, it traverses into the last argument.) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L42-L44","name":"Lean.Parser.Tactic.Conv.lhs","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.lhs","doc":"Traverses into the left subterm of a binary operator.\n(In general, for an `n`-ary operator, it traverses into the second to last argument.) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L39-L40","name":"Lean.Parser.Tactic.Conv.skip","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.skip","doc":"`skip` does nothing. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L26-L37","name":"Lean.Parser.Tactic.Conv.conv","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.conv","doc":"`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://leanprover.github.io/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L24-L24","name":"Lean.Parser.Tactic.Conv.convSeq","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L21-L21","name":"Lean.Parser.Tactic.Conv.convSeqBracketed","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeqBracketed","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L20-L20","name":"Lean.Parser.Tactic.Conv.convSeq1Indented","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.convSeq1Indented","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L13-L18","name":"Lean.Parser.Category.conv","docLink":"./Init/Conv.html#Lean.Parser.Category.conv","doc":"`conv` is the syntax category for a \"conv tactic\", where \"conv\" is short\nfor conversion. A conv tactic is a program which receives a target, printed as\n`| a`, and is tasked with coming up with some term `b` and a proof of `a = b`.\nIt is mainly used for doing targeted term transformations, for example rewriting\nonly on the left side of an equality. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Init/Conv.lean#L13-L18","name":"Lean.Parser.Tactic.Conv.conv.quot","docLink":"./Init/Conv.html#Lean.Parser.Tactic.Conv.conv.quot","doc":""}]}