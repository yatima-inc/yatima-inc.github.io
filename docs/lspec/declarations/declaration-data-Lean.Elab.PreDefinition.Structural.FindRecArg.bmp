{"name":"Lean.Elab.PreDefinition.Structural.FindRecArg","instances":[],"imports":["Init","Lean.Elab.PreDefinition.Structural.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/PreDefinition/Structural/FindRecArg.lean#L74-L137","name":"Lean.Elab.Structural.findRecArg.go","docLink":"./Lean/Elab/PreDefinition/Structural/FindRecArg.html#Lean.Elab.Structural.findRecArg.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/PreDefinition/Structural/FindRecArg.lean#L58-L139","name":"Lean.Elab.Structural.findRecArg","docLink":"./Lean/Elab/PreDefinition/Structural/FindRecArg.html#Lean.Elab.Structural.findRecArg","doc":"Try to find an argument that is structurally smaller in every recursive application.\n  We use this argument to justify termination using the auxiliary `brecOn` construction.\n\n  We give preference for arguments that are *not* indices of inductive types of other arguments.\n  See issue #837 for an example where we can show termination using the index of an inductive family, but\n  we don't get the desired definitional equalities.\n\n  We perform two passes. In the first-pass, we only consider arguments that are not indices.\n  In the second pass, we consider them.\n\n  TODO: explore whether there are better solutions, and whether there are other ways to break the heuristic used\n  for creating the smart unfolding auxiliary definition.\n"}]}