{"name":"Lean.Elab.Config","instances":[],"imports":["Init","Lean.Meta.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Config.lean#L56-L57","name":"Lean.Elab.Term.setElabConfig","docLink":"./Lean/Elab/Config.html#Lean.Elab.Term.setElabConfig","doc":"Set `isDefEq` configuration for the elaborator.\n  Note that we enable all approximations but `quasiPatternApprox`\n\n  In Lean3 and Lean 4, we used to use the quasi-pattern approximation during elaboration.\n  The example:\n  ```\n  def ex : StateT δ (StateT σ Id) σ :=\n  monadLift (get : StateT σ Id σ)\n  ```\n  demonstrates why it produces counterintuitive behavior.\n  We have the `Monad-lift` application:\n  ```\n  @monadLift ?m ?n ?c ?α (get : StateT σ id σ) : ?n ?α\n  ```\n  It produces the following unification problem when we process the expected type:\n  ```\n  ?n ?α =?= StateT δ (StateT σ id) σ\n  ==> (approximate using first-order unification)\n  ?n := StateT δ (StateT σ id)\n  ?α := σ\n  ```\n  Then, we need to solve:\n  ```\n  ?m ?α =?= StateT σ id σ\n  ==> instantiate metavars\n  ?m σ =?= StateT σ id σ\n  ==> (approximate since it is a quasi-pattern unification constraint)\n  ?m := fun σ => StateT σ id σ\n  ```\n  Note that the constraint is not a Milner pattern because σ is in\n  the local context of `?m`. We are ignoring the other possible solutions:\n  ```\n  ?m := fun σ' => StateT σ id σ\n  ?m := fun σ' => StateT σ' id σ\n  ?m := fun σ' => StateT σ id σ'\n  ```\n\n  We need the quasi-pattern approximation for elaborating recursor-like expressions (e.g., dependent `match with` expressions).\n\n  If we had use first-order unification, then we would have produced\n  the right answer: `?m := StateT σ id`\n\n  Haskell would work on this example since it always uses\n  first-order unification.\n"}]}