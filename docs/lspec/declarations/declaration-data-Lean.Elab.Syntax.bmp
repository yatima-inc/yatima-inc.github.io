{"name":"Lean.Elab.Syntax","instances":[],"imports":["Init","Lean.Elab.Command","Lean.Parser.Syntax","Lean.Elab.Util"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L413-L416","name":"Lean.Elab.Command.strLitToPattern","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.strLitToPattern","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L398-L411","name":"Lean.Elab.Command.expandNoKindMacroRulesAux","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.expandNoKindMacroRulesAux","doc":"Infer syntax kind `k` from first pattern, put alternatives of same kind into new `macro/elab_rules (kind := k)` via `mkCmd (some k)`,\nleave remaining alternatives (via `mkCmd none`) to be recursively expanded. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L387-L393","name":"Lean.Elab.Command.inferMacroRulesAltKind","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.inferMacroRulesAltKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L384-L385","name":"Lean.Elab.Command.checkRuleKind","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.checkRuleKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L376-L382","name":"Lean.Elab.Command.elabSyntaxAbbrev","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.elabSyntaxAbbrev","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L343-L374","name":"Lean.Elab.Command.elabSyntax","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.elabSyntax","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L338-L341","name":"Lean.Elab.Command.resolveSyntaxKind","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.resolveSyntaxKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L314-L317","name":"Lean.Elab.Command.mkNameFromParserSyntax.appendCatName","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.mkNameFromParserSyntax.appendCatName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L300-L312","name":"Lean.Elab.Command.mkNameFromParserSyntax.visit","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.mkNameFromParserSyntax.visit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L297-L317","name":"Lean.Elab.Command.mkNameFromParserSyntax","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.mkNameFromParserSyntax","doc":"Auxiliary function for creating declaration names from parser descriptions.\nExample:\nGiven\n```\nsyntax term \"+\" term : term\nsyntax \"[\" sepBy(term, \", \") \"]\"  : term\n```\nIt generates the names `term_+_` and `term[_,]`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L270-L285","name":"Lean.Elab.Command.elabDeclareSyntaxCat","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Command.elabDeclareSyntaxCat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L244-L246","name":"Lean.Elab.Term.toParserDescr.processNonReserved","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processNonReserved","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L231-L242","name":"Lean.Elab.Term.toParserDescr.processAtom","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processAtom","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L224-L229","name":"Lean.Elab.Term.toParserDescr.isValidAtom","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.isValidAtom","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L217-L222","name":"Lean.Elab.Term.toParserDescr.processSepBy1","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processSepBy1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L210-L215","name":"Lean.Elab.Term.toParserDescr.processSepBy","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processSepBy","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L187-L208","name":"Lean.Elab.Term.toParserDescr.processNullaryOrCat","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processNullaryOrCat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L167-L185","name":"Lean.Elab.Term.toParserDescr.processAlias","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processAlias","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L158-L165","name":"Lean.Elab.Term.toParserDescr.processParserCategory","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processParserCategory","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L154-L156","name":"Lean.Elab.Term.toParserDescr.ensureNoPrec","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.ensureNoPrec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L143-L152","name":"Lean.Elab.Term.toParserDescr.processSeq","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.processSeq","doc":"Sequence (aka NullNode) "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L114-L140","name":"Lean.Elab.Term.toParserDescr.process","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr.process","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L108-L246","name":"Lean.Elab.Term.toParserDescr","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.toParserDescr","doc":"Given a `stx` of category `syntax`, return a `(newStx, lhsPrec?)`,\nwhere `newStx` is of category `term`. After elaboration, `newStx` should have type\n`TrailingParserDescr` if `lhsPrec?.isSome`, and `ParserDescr` otherwise. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L85-L101","name":"Lean.Elab.Term.resolveParserName","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.resolveParserName","doc":"Resolve the given parser name and return a list of candidates.\nEach candidate is a pair `(resolvedParserName, isDescr)`.\n`isDescr == true` if the type of `resolvedParserName` is a `ParserDescr`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L68-L80","name":"Lean.Elab.Term.checkLeftRec","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.checkLeftRec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L63-L66","name":"Lean.Elab.Term.addAliasInfo","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.addAliasInfo","doc":"(Try to) add a term info for the alias with info `info` at `ref`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L57-L60","name":"Lean.Elab.Term.addCategoryInfo","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.addCategoryInfo","doc":"(Try to) add a term info for the category `catName` at `ref`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L46-L51","name":"Lean.Elab.Term.ensureUnaryOutput","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ensureUnaryOutput","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L40-L40","name":"Lean.Elab.Term.ToParserDescr","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ToParserDescr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L39-L39","name":"Lean.Elab.Term.ToParserDescrM","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ToParserDescrM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L32-L37","name":"Lean.Elab.Term.ToParserDescrContext","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.ToParserDescrContext","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/fbb858a32cee8090e5390df1fb688b032148645b/src/Lean/Elab/Syntax.lean#L14-L18","name":"Lean.Elab.Term.expandOptPrecedence","docLink":"./Lean/Elab/Syntax.html#Lean.Elab.Term.expandOptPrecedence","doc":"Expand `optional «precedence»` where\n«precedence» := leading_parser \" : \" >> precedenceParser "}]}